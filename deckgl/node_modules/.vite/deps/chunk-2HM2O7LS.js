import {
  __publicField
} from "./chunk-ZC22LKFR.js";

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/row-utils.js
function convertToObjectRow(arrayRow, headers) {
  if (!arrayRow) {
    throw new Error("null row");
  }
  const objectRow = {};
  if (headers) {
    for (let i = 0; i < headers.length; i++) {
      objectRow[headers[i]] = arrayRow[i];
    }
  } else {
    for (let i = 0; i < arrayRow.length; i++) {
      const columnName = `column-${i}`;
      objectRow[columnName] = arrayRow[i];
    }
  }
  return objectRow;
}
function convertToArrayRow(objectRow, headers) {
  if (!objectRow) {
    throw new Error("null row");
  }
  if (headers) {
    const arrayRow = new Array(headers.length);
    for (let i = 0; i < headers.length; i++) {
      arrayRow[i] = objectRow[headers[i]];
    }
    return arrayRow;
  }
  return Object.values(objectRow);
}
function inferHeadersFromArrayRow(arrayRow) {
  const headers = [];
  for (let i = 0; i < arrayRow.length; i++) {
    const columnName = `column-${i}`;
    headers.push(columnName);
  }
  return headers;
}
function inferHeadersFromObjectRow(row) {
  return Object.keys(row);
}

// node_modules/@loaders.gl/schema/dist/lib/table/batches/base-table-batch-aggregator.js
var DEFAULT_ROW_COUNT = 100;
var BaseTableBatchAggregator = class {
  constructor(schema, options) {
    __publicField(this, "schema");
    __publicField(this, "options");
    __publicField(this, "shape");
    __publicField(this, "length", 0);
    __publicField(this, "rows", null);
    __publicField(this, "cursor", 0);
    __publicField(this, "_headers", []);
    this.options = options;
    this.schema = schema;
    if (!Array.isArray(schema)) {
      this._headers = [];
      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    this.shape = "array-row-table";
    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
    this.rows[this.length] = row;
    this.length++;
  }
  addObjectRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    this.shape = "object-row-table";
    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);
    this.rows[this.length] = row;
    this.length++;
  }
  getBatch() {
    let rows = this.rows;
    if (!rows) {
      return null;
    }
    rows = rows.slice(0, this.length);
    this.rows = null;
    const batch = {
      shape: this.shape || "array-row-table",
      batchType: "data",
      data: rows,
      length: this.length,
      schema: this.schema,
      cursor: this.cursor
    };
    return batch;
  }
};

// node_modules/@loaders.gl/schema/dist/lib/table/batches/row-table-batch-aggregator.js
var DEFAULT_ROW_COUNT2 = 100;
var RowTableBatchAggregator = class {
  constructor(schema, options) {
    __publicField(this, "schema");
    __publicField(this, "options");
    __publicField(this, "length", 0);
    __publicField(this, "objectRows", null);
    __publicField(this, "arrayRows", null);
    __publicField(this, "cursor", 0);
    __publicField(this, "_headers", null);
    this.options = options;
    this.schema = schema;
    if (schema) {
      this._headers = [];
      for (const key in schema) {
        this._headers[schema[key].index] = schema[key].name;
      }
    }
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    this._headers || (this._headers = inferHeadersFromArrayRow(row));
    switch (this.options.shape) {
      case "object-row-table":
        const rowObject = convertToObjectRow(row, this._headers);
        this.addObjectRow(rowObject, cursor);
        break;
      case "array-row-table":
        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT2);
        this.arrayRows[this.length] = row;
        this.length++;
        break;
    }
  }
  addObjectRow(row, cursor) {
    if (Number.isFinite(cursor)) {
      this.cursor = cursor;
    }
    this._headers || (this._headers = inferHeadersFromObjectRow(row));
    switch (this.options.shape) {
      case "array-row-table":
        const rowArray = convertToArrayRow(row, this._headers);
        this.addArrayRow(rowArray, cursor);
        break;
      case "object-row-table":
        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT2);
        this.objectRows[this.length] = row;
        this.length++;
        break;
    }
  }
  getBatch() {
    let rows = this.arrayRows || this.objectRows;
    if (!rows) {
      return null;
    }
    rows = rows.slice(0, this.length);
    this.arrayRows = null;
    this.objectRows = null;
    return {
      shape: this.options.shape,
      batchType: "data",
      data: rows,
      length: this.length,
      // @ts-expect-error we should infer a schema
      schema: this.schema,
      cursor: this.cursor
    };
  }
};

// node_modules/@loaders.gl/schema/dist/lib/table/batches/columnar-table-batch-aggregator.js
var DEFAULT_ROW_COUNT3 = 100;
var ColumnarTableBatchAggregator = class {
  constructor(schema, options) {
    __publicField(this, "schema");
    __publicField(this, "length", 0);
    __publicField(this, "allocated", 0);
    __publicField(this, "columns", {});
    this.schema = schema;
    this._reallocateColumns();
  }
  rowCount() {
    return this.length;
  }
  addArrayRow(row) {
    this._reallocateColumns();
    let i = 0;
    for (const fieldName in this.columns) {
      this.columns[fieldName][this.length] = row[i++];
    }
    this.length++;
  }
  addObjectRow(row) {
    this._reallocateColumns();
    for (const fieldName in row) {
      this.columns[fieldName][this.length] = row[fieldName];
    }
    this.length++;
  }
  getBatch() {
    this._pruneColumns();
    const columns = Array.isArray(this.schema) ? this.columns : {};
    if (!Array.isArray(this.schema)) {
      for (const fieldName in this.schema) {
        const field = this.schema[fieldName];
        columns[field.name] = this.columns[field.index];
      }
    }
    this.columns = {};
    const batch = {
      shape: "columnar-table",
      batchType: "data",
      data: columns,
      schema: this.schema,
      length: this.length
    };
    return batch;
  }
  // HELPERS
  _reallocateColumns() {
    if (this.length < this.allocated) {
      return;
    }
    this.allocated = this.allocated > 0 ? this.allocated *= 2 : DEFAULT_ROW_COUNT3;
    this.columns = {};
    for (const fieldName in this.schema) {
      const field = this.schema[fieldName];
      const ArrayType = field.type || Float32Array;
      const oldColumn = this.columns[field.index];
      if (oldColumn && ArrayBuffer.isView(oldColumn)) {
        const typedArray = new ArrayType(this.allocated);
        typedArray.set(oldColumn);
        this.columns[field.index] = typedArray;
      } else if (oldColumn) {
        oldColumn.length = this.allocated;
        this.columns[field.index] = oldColumn;
      } else {
        this.columns[field.index] = new ArrayType(this.allocated);
      }
    }
  }
  _pruneColumns() {
    for (const [columnName, column] of Object.entries(this.columns)) {
      this.columns[columnName] = column.slice(0, this.length);
    }
  }
};

// node_modules/@loaders.gl/schema/dist/lib/table/batches/table-batch-builder.js
var DEFAULT_OPTIONS = {
  shape: void 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  limit: 0,
  _limitMB: 0
};
var ERR_MESSAGE = "TableBatchBuilder";
var _TableBatchBuilder = class _TableBatchBuilder {
  constructor(schema, options) {
    __publicField(this, "schema");
    __publicField(this, "options");
    __publicField(this, "aggregator", null);
    __publicField(this, "batchCount", 0);
    __publicField(this, "bytesUsed", 0);
    __publicField(this, "isChunkComplete", false);
    __publicField(this, "lastBatchEmittedMs", Date.now());
    __publicField(this, "totalLength", 0);
    __publicField(this, "totalBytes", 0);
    __publicField(this, "rowBytes", 0);
    this.schema = schema;
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }
  limitReached() {
    var _a, _b;
    if (Boolean((_a = this.options) == null ? void 0 : _a.limit) && this.totalLength >= this.options.limit) {
      return true;
    }
    if (Boolean((_b = this.options) == null ? void 0 : _b._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {
      return true;
    }
    return false;
  }
  /** @deprecated Use addArrayRow or addObjectRow */
  addRow(row) {
    if (this.limitReached()) {
      return;
    }
    this.totalLength++;
    this.rowBytes = this.rowBytes || this._estimateRowMB(row);
    this.totalBytes += this.rowBytes;
    if (Array.isArray(row)) {
      this.addArrayRow(row);
    } else {
      this.addObjectRow(row);
    }
  }
  /** Add one row to the batch */
  addArrayRow(row) {
    if (!this.aggregator) {
      const TableBatchType = this._getTableBatchType();
      this.aggregator = new TableBatchType(this.schema, this.options);
    }
    this.aggregator.addArrayRow(row);
  }
  /** Add one row to the batch */
  addObjectRow(row) {
    if (!this.aggregator) {
      const TableBatchType = this._getTableBatchType();
      this.aggregator = new TableBatchType(this.schema, this.options);
    }
    this.aggregator.addObjectRow(row);
  }
  /** Mark an incoming raw memory chunk has completed */
  chunkComplete(chunk) {
    if (chunk instanceof ArrayBuffer) {
      this.bytesUsed += chunk.byteLength;
    }
    if (typeof chunk === "string") {
      this.bytesUsed += chunk.length;
    }
    this.isChunkComplete = true;
  }
  getFullBatch(options) {
    return this._isFull() ? this._getBatch(options) : null;
  }
  getFinalBatch(options) {
    return this._getBatch(options);
  }
  // INTERNAL
  _estimateRowMB(row) {
    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;
  }
  _isFull() {
    if (!this.aggregator || this.aggregator.rowCount() === 0) {
      return false;
    }
    if (this.options.batchSize === "auto") {
      if (!this.isChunkComplete) {
        return false;
      }
    } else if (this.options.batchSize > this.aggregator.rowCount()) {
      return false;
    }
    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {
      return false;
    }
    this.isChunkComplete = false;
    this.lastBatchEmittedMs = Date.now();
    return true;
  }
  /**
   * bytesUsed can be set via chunkComplete or via getBatch*
   */
  _getBatch(options) {
    if (!this.aggregator) {
      return null;
    }
    if (options == null ? void 0 : options.bytesUsed) {
      this.bytesUsed = options.bytesUsed;
    }
    const normalizedBatch = this.aggregator.getBatch();
    normalizedBatch.count = this.batchCount;
    normalizedBatch.bytesUsed = this.bytesUsed;
    Object.assign(normalizedBatch, options);
    this.batchCount++;
    this.aggregator = null;
    return normalizedBatch;
  }
  _getTableBatchType() {
    switch (this.options.shape) {
      case "array-row-table":
      case "object-row-table":
        return RowTableBatchAggregator;
      case "columnar-table":
        return ColumnarTableBatchAggregator;
      case "arrow-table":
        if (!_TableBatchBuilder.ArrowBatch) {
          throw new Error(ERR_MESSAGE);
        }
        return _TableBatchBuilder.ArrowBatch;
      default:
        return BaseTableBatchAggregator;
    }
  }
};
__publicField(_TableBatchBuilder, "ArrowBatch");
var TableBatchBuilder = _TableBatchBuilder;

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/table-accessors.js
function isTable(table) {
  var _a;
  const shape = typeof table === "object" && (table == null ? void 0 : table.shape);
  switch (shape) {
    case "array-row-table":
    case "object-row-table":
      return Array.isArray(table.data);
    case "geojson-table":
      return Array.isArray(table.features);
    case "columnar-table":
      return table.data && typeof table.data === "object";
    case "arrow-table":
      return Boolean(((_a = table == null ? void 0 : table.data) == null ? void 0 : _a.numRows) !== void 0);
    default:
      return false;
  }
}
function getTableLength(table) {
  switch (table.shape) {
    case "array-row-table":
    case "object-row-table":
      return table.data.length;
    case "geojson-table":
      return table.features.length;
    case "arrow-table":
      const arrowTable = table.data;
      return arrowTable.numRows;
    case "columnar-table":
      for (const column of Object.values(table.data)) {
        return column.length || 0;
      }
      return 0;
    default:
      throw new Error("table");
  }
}
function getTableNumCols(table) {
  if (table.schema) {
    return table.schema.fields.length;
  }
  if (getTableLength(table) === 0) {
    throw new Error("empty table");
  }
  switch (table.shape) {
    case "array-row-table":
      return table.data[0].length;
    case "object-row-table":
      return Object.keys(table.data[0]).length;
    case "geojson-table":
      return Object.keys(table.features[0]).length;
    case "columnar-table":
      return Object.keys(table.data).length;
    case "arrow-table":
      const arrowTable = table.data;
      return arrowTable.numCols;
    default:
      throw new Error("table");
  }
}
function getTableRowAsObject(table, rowIndex, target, copy) {
  switch (table.shape) {
    case "object-row-table":
      return copy ? Object.fromEntries(Object.entries(table.data[rowIndex])) : table.data[rowIndex];
    case "array-row-table":
      if (table.schema) {
        const objectRow2 = target || {};
        for (let i = 0; i < table.schema.fields.length; i++) {
          objectRow2[table.schema.fields[i].name] = table.data[rowIndex][i];
        }
        return objectRow2;
      }
      throw new Error("no schema");
    case "geojson-table":
      if (table.schema) {
        const objectRow2 = target || {};
        for (let i = 0; i < table.schema.fields.length; i++) {
          objectRow2[table.schema.fields[i].name] = table.features[rowIndex][i];
        }
        return objectRow2;
      }
      throw new Error("no schema");
    case "columnar-table":
      if (table.schema) {
        const objectRow2 = target || {};
        for (let i = 0; i < table.schema.fields.length; i++) {
          objectRow2[table.schema.fields[i].name] = table.data[table.schema.fields[i].name][rowIndex];
        }
        return objectRow2;
      } else {
        const objectRow2 = target || {};
        for (const [name, column] of Object.entries(table.data)) {
          objectRow2[name] = column[rowIndex];
        }
        return objectRow2;
      }
    case "arrow-table":
      const arrowTable = table.data;
      const objectRow = target || {};
      const row = arrowTable.get(rowIndex);
      const schema = arrowTable.schema;
      for (let i = 0; i < schema.fields.length; i++) {
        objectRow[schema.fields[i].name] = row == null ? void 0 : row[schema.fields[i].name];
      }
      return objectRow;
    default:
      throw new Error("shape");
  }
}
function getTableRowAsArray(table, rowIndex, target, copy) {
  switch (table.shape) {
    case "array-row-table":
      return copy ? Array.from(table.data[rowIndex]) : table.data[rowIndex];
    case "object-row-table":
      if (table.schema) {
        const arrayRow2 = target || [];
        for (let i = 0; i < table.schema.fields.length; i++) {
          arrayRow2[i] = table.data[rowIndex][table.schema.fields[i].name];
        }
        return arrayRow2;
      }
      return Object.values(table.data[rowIndex]);
    case "geojson-table":
      if (table.schema) {
        const arrayRow2 = target || [];
        for (let i = 0; i < table.schema.fields.length; i++) {
          arrayRow2[i] = table.features[rowIndex][table.schema.fields[i].name];
        }
        return arrayRow2;
      }
      return Object.values(table.features[rowIndex]);
    case "columnar-table":
      if (table.schema) {
        const arrayRow2 = target || [];
        for (let i = 0; i < table.schema.fields.length; i++) {
          arrayRow2[i] = table.data[table.schema.fields[i].name][rowIndex];
        }
        return arrayRow2;
      } else {
        const arrayRow2 = target || [];
        let i = 0;
        for (const column of Object.values(table.data)) {
          arrayRow2[i] = column[rowIndex];
          i++;
        }
        return arrayRow2;
      }
    case "arrow-table":
      const arrowTable = table.data;
      const arrayRow = target || [];
      const row = arrowTable.get(rowIndex);
      const schema = arrowTable.schema;
      for (let i = 0; i < schema.fields.length; i++) {
        arrayRow[i] = row == null ? void 0 : row[schema.fields[i].name];
      }
      return arrayRow;
    default:
      throw new Error("shape");
  }
}
function* makeRowIterator(table, shape) {
  switch (shape) {
    case "array-row-table":
      yield* makeArrayRowIterator(table);
      break;
    case "object-row-table":
      yield* makeObjectRowIterator(table);
      break;
    default:
      throw new Error(`Unknown row type ${shape}`);
  }
}
function* makeArrayRowIterator(table, target = []) {
  const length = getTableLength(table);
  for (let rowIndex = 0; rowIndex < length; rowIndex++) {
    yield getTableRowAsArray(table, rowIndex, target);
  }
}
function* makeObjectRowIterator(table, target = {}) {
  const length = getTableLength(table);
  for (let rowIndex = 0; rowIndex < length; rowIndex++) {
    yield getTableRowAsObject(table, rowIndex, target);
  }
}

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/make-table-from-batches.js
function makeBatchFromTable(table) {
  return { ...table, length: getTableLength(table), batchType: "data" };
}

// node_modules/@loaders.gl/schema/dist/lib/utils/async-queue.js
var ArrayQueue = class extends Array {
  enqueue(value) {
    return this.push(value);
  }
  dequeue() {
    return this.shift();
  }
};
var AsyncQueue = class {
  constructor() {
    __publicField(this, "_values");
    __publicField(this, "_settlers");
    __publicField(this, "_closed");
    this._values = new ArrayQueue();
    this._settlers = new ArrayQueue();
    this._closed = false;
  }
  close() {
    while (this._settlers.length > 0) {
      this._settlers.dequeue().resolve({ done: true });
    }
    this._closed = true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  enqueue(value) {
    if (this._closed) {
      throw new Error("Closed");
    }
    if (this._settlers.length > 0) {
      if (this._values.length > 0) {
        throw new Error("Illegal internal state");
      }
      const settler = this._settlers.dequeue();
      if (value instanceof Error) {
        settler.reject(value);
      } else {
        settler.resolve({ value });
      }
    } else {
      this._values.enqueue(value);
    }
  }
  /**
   * @returns a Promise for an IteratorResult
   */
  next() {
    if (this._values.length > 0) {
      const value = this._values.dequeue();
      if (value instanceof Error) {
        return Promise.reject(value);
      }
      return Promise.resolve({ value });
    }
    if (this._closed) {
      if (this._settlers.length > 0) {
        throw new Error("Illegal internal state");
      }
      return Promise.resolve({ done: true });
    }
    return new Promise((resolve, reject) => {
      this._settlers.enqueue({ resolve, reject });
    });
  }
};

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/data-type.js
function getDataTypeFromValue(value, defaultNumberType = "float32") {
  if (value instanceof Date) {
    return "date-millisecond";
  }
  if (value instanceof Number) {
    return defaultNumberType;
  }
  if (typeof value === "string") {
    return "utf8";
  }
  if (value === null || value === "undefined") {
    return "null";
  }
  return "null";
}
function getDataTypeFromArray(array) {
  let type = getDataTypeFromTypedArray(array);
  if (type !== "null") {
    return { type, nullable: false };
  }
  if (array.length > 0) {
    type = getDataTypeFromValue(array[0]);
    return { type, nullable: true };
  }
  return { type: "null", nullable: true };
}
function getDataTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/table-schema.js
function deduceTableSchema(table) {
  switch (table.shape) {
    case "array-row-table":
    case "object-row-table":
      return deduceSchemaFromRows(table.data);
    case "geojson-table":
      return deduceSchemaFromGeoJSON(table.features);
    case "columnar-table":
      return deduceSchemaFromColumns(table.data);
    case "arrow-table":
    default:
      throw new Error("Deduce schema");
  }
}
function deduceSchemaFromColumns(columnarTable) {
  const fields = [];
  for (const [columnName, column] of Object.entries(columnarTable)) {
    const field = deduceFieldFromColumn(column, columnName);
    fields.push(field);
  }
  return { fields, metadata: {} };
}
function deduceSchemaFromRows(rowTable) {
  if (!rowTable.length) {
    throw new Error("deduce from empty table");
  }
  const fields = [];
  const row0 = rowTable[0];
  for (const [columnName, value] of Object.entries(row0)) {
    fields.push(deduceFieldFromValue(value, columnName));
  }
  return { fields, metadata: {} };
}
function deduceSchemaFromGeoJSON(features) {
  if (!features.length) {
    throw new Error("deduce from empty table");
  }
  const fields = [];
  const row0 = features[0].properties || {};
  for (const [columnName, value] of Object.entries(row0)) {
    fields.push(deduceFieldFromValue(value, columnName));
  }
  return { fields, metadata: {} };
}
function deduceFieldFromColumn(column, name) {
  if (ArrayBuffer.isView(column)) {
    const type = getDataTypeFromArray(column);
    return {
      name,
      type: type.type || "null",
      nullable: type.nullable
      // metadata: {}
    };
  }
  if (Array.isArray(column) && column.length > 0) {
    const value = column[0];
    const type = getDataTypeFromValue(value);
    return {
      name,
      type,
      nullable: true
      // metadata: {},
    };
  }
  throw new Error("empty table");
}
function deduceFieldFromValue(value, name) {
  const type = getDataTypeFromValue(value);
  return {
    name,
    type,
    nullable: true
    // metadata: {}
  };
}

// node_modules/@loaders.gl/schema/dist/lib/table/simple-table/make-table.js
function makeTableFromData(data) {
  let table;
  switch (getTableShapeFromData(data)) {
    case "array-row-table":
      table = { shape: "array-row-table", data };
      break;
    case "object-row-table":
      table = { shape: "object-row-table", data };
      break;
    case "columnar-table":
      table = { shape: "columnar-table", data };
      break;
    default:
      throw new Error("table");
  }
  const schema = deduceTableSchema(table);
  return { ...table, schema };
}
function getTableShapeFromData(data) {
  if (Array.isArray(data)) {
    if (data.length === 0) {
      throw new Error("cannot deduce type of empty table");
    }
    const firstRow = data[0];
    if (Array.isArray(firstRow)) {
      return "array-row-table";
    }
    if (firstRow && typeof firstRow === "object") {
      return "object-row-table";
    }
  }
  if (data && typeof data === "object") {
    return "columnar-table";
  }
  throw new Error("invalid table");
}

// node_modules/@loaders.gl/schema/dist/lib/table/arrow-api/enum.js
var Type;
(function(Type2) {
  Type2[Type2["NONE"] = 0] = "NONE";
  Type2[Type2["Null"] = 1] = "Null";
  Type2[Type2["Int"] = 2] = "Int";
  Type2[Type2["Float"] = 3] = "Float";
  Type2[Type2["Binary"] = 4] = "Binary";
  Type2[Type2["Utf8"] = 5] = "Utf8";
  Type2[Type2["Bool"] = 6] = "Bool";
  Type2[Type2["Decimal"] = 7] = "Decimal";
  Type2[Type2["Date"] = 8] = "Date";
  Type2[Type2["Time"] = 9] = "Time";
  Type2[Type2["Timestamp"] = 10] = "Timestamp";
  Type2[Type2["Interval"] = 11] = "Interval";
  Type2[Type2["List"] = 12] = "List";
  Type2[Type2["Struct"] = 13] = "Struct";
  Type2[Type2["Union"] = 14] = "Union";
  Type2[Type2["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type2[Type2["FixedSizeList"] = 16] = "FixedSizeList";
  Type2[Type2["Map"] = 17] = "Map";
  Type2[Type2["Dictionary"] = -1] = "Dictionary";
  Type2[Type2["Int8"] = -2] = "Int8";
  Type2[Type2["Int16"] = -3] = "Int16";
  Type2[Type2["Int32"] = -4] = "Int32";
  Type2[Type2["Int64"] = -5] = "Int64";
  Type2[Type2["Uint8"] = -6] = "Uint8";
  Type2[Type2["Uint16"] = -7] = "Uint16";
  Type2[Type2["Uint32"] = -8] = "Uint32";
  Type2[Type2["Uint64"] = -9] = "Uint64";
  Type2[Type2["Float16"] = -10] = "Float16";
  Type2[Type2["Float32"] = -11] = "Float32";
  Type2[Type2["Float64"] = -12] = "Float64";
  Type2[Type2["DateDay"] = -13] = "DateDay";
  Type2[Type2["DateMillisecond"] = -14] = "DateMillisecond";
  Type2[Type2["TimestampSecond"] = -15] = "TimestampSecond";
  Type2[Type2["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type2[Type2["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type2[Type2["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type2[Type2["TimeSecond"] = -19] = "TimeSecond";
  Type2[Type2["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type2[Type2["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type2[Type2["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type2[Type2["DenseUnion"] = -23] = "DenseUnion";
  Type2[Type2["SparseUnion"] = -24] = "SparseUnion";
  Type2[Type2["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type2[Type2["IntervalYearMonth"] = -26] = "IntervalYearMonth";
})(Type || (Type = {}));

// node_modules/@loaders.gl/schema/dist/lib/table/arrow-api/arrow-like-type.js
var DataType = class {
  static isNull(x) {
    return x && x.typeId === Type.Null;
  }
  static isInt(x) {
    return x && x.typeId === Type.Int;
  }
  static isFloat(x) {
    return x && x.typeId === Type.Float;
  }
  static isBinary(x) {
    return x && x.typeId === Type.Binary;
  }
  static isUtf8(x) {
    return x && x.typeId === Type.Utf8;
  }
  static isBool(x) {
    return x && x.typeId === Type.Bool;
  }
  static isDecimal(x) {
    return x && x.typeId === Type.Decimal;
  }
  static isDate(x) {
    return x && x.typeId === Type.Date;
  }
  static isTime(x) {
    return x && x.typeId === Type.Time;
  }
  static isTimestamp(x) {
    return x && x.typeId === Type.Timestamp;
  }
  static isInterval(x) {
    return x && x.typeId === Type.Interval;
  }
  static isList(x) {
    return x && x.typeId === Type.List;
  }
  static isStruct(x) {
    return x && x.typeId === Type.Struct;
  }
  static isUnion(x) {
    return x && x.typeId === Type.Union;
  }
  static isFixedSizeBinary(x) {
    return x && x.typeId === Type.FixedSizeBinary;
  }
  static isFixedSizeList(x) {
    return x && x.typeId === Type.FixedSizeList;
  }
  static isMap(x) {
    return x && x.typeId === Type.Map;
  }
  static isDictionary(x) {
    return x && x.typeId === Type.Dictionary;
  }
  get typeId() {
    return Type.NONE;
  }
  // get ArrayType(): AnyArrayType {
  //   return Int8Array;
  // }
  // get ArrayType() { return Array; }
  compareTo(other) {
    return this === other;
  }
};
var Null = class extends DataType {
  get typeId() {
    return Type.Null;
  }
  get [Symbol.toStringTag]() {
    return "Null";
  }
  toString() {
    return "Null";
  }
};
var Bool = class extends DataType {
  get typeId() {
    return Type.Bool;
  }
  // get ArrayType() {
  //   return Uint8Array;
  // }
  get [Symbol.toStringTag]() {
    return "Bool";
  }
  toString() {
    return "Bool";
  }
};
var Int = class extends DataType {
  constructor(isSigned, bitWidth) {
    super();
    __publicField(this, "isSigned");
    __publicField(this, "bitWidth");
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type.Int;
  }
  // get ArrayType() {
  //   switch (this.bitWidth) {
  //     case 8:
  //       return this.isSigned ? Int8Array : Uint8Array;
  //     case 16:
  //       return this.isSigned ? Int16Array : Uint16Array;
  //     case 32:
  //       return this.isSigned ? Int32Array : Uint32Array;
  //     case 64:
  //       return this.isSigned ? Int32Array : Uint32Array;
  //     default:
  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  //   }
  // }
  get [Symbol.toStringTag]() {
    return "Int";
  }
  toString() {
    return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
  }
};
var Float = class extends DataType {
  constructor(precision) {
    super();
    __publicField(this, "precision");
    this.precision = precision;
  }
  get typeId() {
    return Type.Float;
  }
  // get ArrayType() {
  //   switch (this.precision) {
  //     case Precision.HALF:
  //       return Uint16Array;
  //     case Precision.SINGLE:
  //       return Float32Array;
  //     case Precision.DOUBLE:
  //       return Float64Array;
  //     default:
  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  //   }
  // }
  get [Symbol.toStringTag]() {
    return "Float";
  }
  toString() {
    return `Float${this.precision}`;
  }
};
var Binary = class extends DataType {
  constructor() {
    super();
  }
  get typeId() {
    return Type.Binary;
  }
  toString() {
    return "Binary";
  }
  get [Symbol.toStringTag]() {
    return "Binary";
  }
};
var Utf8 = class extends DataType {
  get typeId() {
    return Type.Utf8;
  }
  // get ArrayType() {
  //   return Uint8Array;
  // }
  get [Symbol.toStringTag]() {
    return "Utf8";
  }
  toString() {
    return "Utf8";
  }
};
var DateUnit = {
  DAY: 0,
  MILLISECOND: 1
};
var Date2 = class extends DataType {
  constructor(unit) {
    super();
    __publicField(this, "unit");
    this.unit = unit;
  }
  get typeId() {
    return Type.Date;
  }
  // get ArrayType() {
  //   return Int32Array;
  // }
  get [Symbol.toStringTag]() {
    return "Date";
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
  }
};
var TimeUnit = {
  SECOND: 1,
  MILLISECOND: 1e3,
  MICROSECOND: 1e6,
  NANOSECOND: 1e9
};
var Time = class extends DataType {
  constructor(unit, bitWidth) {
    super();
    __publicField(this, "unit");
    __publicField(this, "bitWidth");
    this.unit = unit;
    this.bitWidth = bitWidth;
  }
  get typeId() {
    return Type.Time;
  }
  toString() {
    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
  }
  get [Symbol.toStringTag]() {
    return "Time";
  }
};
var Timestamp = class extends DataType {
  constructor(unit, timezone = null) {
    super();
    __publicField(this, "unit");
    __publicField(this, "timezone");
    this.unit = unit;
    this.timezone = timezone;
  }
  get typeId() {
    return Type.Timestamp;
  }
  // get ArrayType() {
  //   return Int32Array;
  // }
  get [Symbol.toStringTag]() {
    return "Timestamp";
  }
  toString() {
    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
  }
};
var IntervalUnit = {
  DAY_TIME: 0,
  YEAR_MONTH: 1
};
var Interval = class extends DataType {
  constructor(unit) {
    super();
    __publicField(this, "unit");
    this.unit = unit;
  }
  get typeId() {
    return Type.Interval;
  }
  // get ArrayType() {
  //   return Int32Array;
  // }
  get [Symbol.toStringTag]() {
    return "Interval";
  }
  toString() {
    return `Interval<${IntervalUnit[this.unit]}>`;
  }
};
var FixedSizeList = class extends DataType {
  constructor(listSize, child) {
    super();
    __publicField(this, "listSize");
    __publicField(this, "children");
    this.listSize = listSize;
    this.children = [child];
  }
  get typeId() {
    return Type.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  // get ArrayType() {
  //   return this.valueType.ArrayType;
  // }
  get [Symbol.toStringTag]() {
    return "FixedSizeList";
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${JSON.stringify(this.valueType)}>`;
  }
};
var Struct = class extends DataType {
  constructor(children) {
    super();
    __publicField(this, "children");
    this.children = children;
  }
  get typeId() {
    return Type.Struct;
  }
  toString() {
    return `Struct<{${this.children.map((f) => `${f.name}:${JSON.stringify(f.type)}`).join(", ")}}>`;
  }
  get [Symbol.toStringTag]() {
    return "Struct";
  }
};

export {
  convertToObjectRow,
  convertToArrayRow,
  TableBatchBuilder,
  isTable,
  getTableLength,
  getTableNumCols,
  getTableRowAsObject,
  getTableRowAsArray,
  makeRowIterator,
  makeArrayRowIterator,
  makeTableFromData,
  makeBatchFromTable,
  AsyncQueue
};
//# sourceMappingURL=chunk-2HM2O7LS.js.map
