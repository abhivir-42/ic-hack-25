import {
  earcut,
  getPolygonSignedArea
} from "./chunk-HKQUXZTY.js";
import "./chunk-YXBUOVSR.js";
import {
  assert,
  concatenateArrayBuffersAsync,
  makeLineIterator,
  makeNumberedLineIterator,
  makeTextDecoderIterator
} from "./chunk-M445ZNT3.js";
import {
  TableBatchBuilder,
  getTableLength,
  getTableNumCols,
  getTableRowAsArray,
  getTableRowAsObject,
  makeRowIterator,
  makeTableFromData
} from "./chunk-2HM2O7LS.js";
import {
  __publicField
} from "./chunk-ZC22LKFR.js";

// node_modules/@loaders.gl/json/dist/lib/parsers/parse-json.js
function parseJSONSync(jsonText, options) {
  var _a;
  try {
    const json = JSON.parse(jsonText);
    if ((_a = options.json) == null ? void 0 : _a.table) {
      const data = getFirstArray(json) || json;
      return makeTableFromData(data);
    }
    return json;
  } catch (error) {
    throw new Error("JSONLoader: failed to parse JSON");
  }
}
function getFirstArray(json) {
  if (Array.isArray(json)) {
    return json;
  }
  if (json && typeof json === "object") {
    for (const value of Object.values(json)) {
      const array = getFirstArray(value);
      if (array) {
        return array;
      }
    }
  }
  return null;
}

// node_modules/@loaders.gl/json/dist/lib/clarinet/clarinet.js
var MAX_BUFFER_LENGTH = Number.MAX_SAFE_INTEGER;
var STATE;
(function(STATE2) {
  STATE2[STATE2["BEGIN"] = 0] = "BEGIN";
  STATE2[STATE2["VALUE"] = 1] = "VALUE";
  STATE2[STATE2["OPEN_OBJECT"] = 2] = "OPEN_OBJECT";
  STATE2[STATE2["CLOSE_OBJECT"] = 3] = "CLOSE_OBJECT";
  STATE2[STATE2["OPEN_ARRAY"] = 4] = "OPEN_ARRAY";
  STATE2[STATE2["CLOSE_ARRAY"] = 5] = "CLOSE_ARRAY";
  STATE2[STATE2["TEXT_ESCAPE"] = 6] = "TEXT_ESCAPE";
  STATE2[STATE2["STRING"] = 7] = "STRING";
  STATE2[STATE2["BACKSLASH"] = 8] = "BACKSLASH";
  STATE2[STATE2["END"] = 9] = "END";
  STATE2[STATE2["OPEN_KEY"] = 10] = "OPEN_KEY";
  STATE2[STATE2["CLOSE_KEY"] = 11] = "CLOSE_KEY";
  STATE2[STATE2["TRUE"] = 12] = "TRUE";
  STATE2[STATE2["TRUE2"] = 13] = "TRUE2";
  STATE2[STATE2["TRUE3"] = 14] = "TRUE3";
  STATE2[STATE2["FALSE"] = 15] = "FALSE";
  STATE2[STATE2["FALSE2"] = 16] = "FALSE2";
  STATE2[STATE2["FALSE3"] = 17] = "FALSE3";
  STATE2[STATE2["FALSE4"] = 18] = "FALSE4";
  STATE2[STATE2["NULL"] = 19] = "NULL";
  STATE2[STATE2["NULL2"] = 20] = "NULL2";
  STATE2[STATE2["NULL3"] = 21] = "NULL3";
  STATE2[STATE2["NUMBER_DECIMAL_POINT"] = 22] = "NUMBER_DECIMAL_POINT";
  STATE2[STATE2["NUMBER_DIGIT"] = 23] = "NUMBER_DIGIT";
})(STATE || (STATE = {}));
var Char = {
  tab: 9,
  // \t
  lineFeed: 10,
  // \n
  carriageReturn: 13,
  // \r
  space: 32,
  // " "
  doubleQuote: 34,
  // "
  plus: 43,
  // +
  comma: 44,
  // ,
  minus: 45,
  // -
  period: 46,
  // .
  _0: 48,
  // 0
  _9: 57,
  // 9
  colon: 58,
  // :
  E: 69,
  // E
  openBracket: 91,
  // [
  backslash: 92,
  // \
  closeBracket: 93,
  // ]
  a: 97,
  // a
  b: 98,
  // b
  e: 101,
  // e
  f: 102,
  // f
  l: 108,
  // l
  n: 110,
  // n
  r: 114,
  // r
  s: 115,
  // s
  t: 116,
  // t
  u: 117,
  // u
  openBrace: 123,
  // {
  closeBrace: 125
  // }
};
var stringTokenPattern = /[\\"\n]/g;
var DEFAULT_OPTIONS = {
  onready: () => {
  },
  onopenobject: () => {
  },
  onkey: () => {
  },
  oncloseobject: () => {
  },
  onopenarray: () => {
  },
  onclosearray: () => {
  },
  onvalue: () => {
  },
  onerror: () => {
  },
  onend: () => {
  },
  onchunkparsed: () => {
  }
};
var ClarinetParser = class {
  constructor(options = {}) {
    __publicField(this, "options", DEFAULT_OPTIONS);
    __publicField(this, "bufferCheckPosition", MAX_BUFFER_LENGTH);
    __publicField(this, "q", "");
    __publicField(this, "c", "");
    __publicField(this, "p", "");
    __publicField(this, "closed", false);
    __publicField(this, "closedRoot", false);
    __publicField(this, "sawRoot", false);
    // tag = null;
    __publicField(this, "error", null);
    __publicField(this, "state", STATE.BEGIN);
    __publicField(this, "stack", []);
    // mostly just for error reporting
    __publicField(this, "position", 0);
    __publicField(this, "column", 0);
    __publicField(this, "line", 1);
    __publicField(this, "slashed", false);
    __publicField(this, "unicodeI", 0);
    __publicField(this, "unicodeS", null);
    __publicField(this, "depth", 0);
    __publicField(this, "textNode");
    __publicField(this, "numberNode");
    this.options = { ...DEFAULT_OPTIONS, ...options };
    this.textNode = void 0;
    this.numberNode = "";
    this.emit("onready");
  }
  end() {
    if (this.state !== STATE.VALUE || this.depth !== 0)
      this._error("Unexpected end");
    this._closeValue();
    this.c = "";
    this.closed = true;
    this.emit("onend");
    return this;
  }
  resume() {
    this.error = null;
    return this;
  }
  close() {
    return this.write(null);
  }
  // protected
  emit(event, data) {
    var _a, _b;
    (_b = (_a = this.options)[event]) == null ? void 0 : _b.call(_a, data, this);
  }
  emitNode(event, data) {
    this._closeValue();
    this.emit(event, data);
  }
  /* eslint-disable no-continue */
  // eslint-disable-next-line complexity, max-statements
  write(chunk) {
    if (this.error) {
      throw this.error;
    }
    if (this.closed) {
      return this._error("Cannot write after close. Assign an onready handler.");
    }
    if (chunk === null) {
      return this.end();
    }
    let i = 0;
    let c = chunk.charCodeAt(0);
    let p = this.p;
    while (c) {
      p = c;
      this.c = c = chunk.charCodeAt(i++);
      if (p !== c) {
        this.p = p;
      } else {
        p = this.p;
      }
      if (!c)
        break;
      this.position++;
      if (c === Char.lineFeed) {
        this.line++;
        this.column = 0;
      } else
        this.column++;
      switch (this.state) {
        case STATE.BEGIN:
          if (c === Char.openBrace)
            this.state = STATE.OPEN_OBJECT;
          else if (c === Char.openBracket)
            this.state = STATE.OPEN_ARRAY;
          else if (!isWhitespace(c)) {
            this._error("Non-whitespace before {[.");
          }
          continue;
        case STATE.OPEN_KEY:
        case STATE.OPEN_OBJECT:
          if (isWhitespace(c))
            continue;
          if (this.state === STATE.OPEN_KEY)
            this.stack.push(STATE.CLOSE_KEY);
          else if (c === Char.closeBrace) {
            this.emit("onopenobject");
            this.depth++;
            this.emit("oncloseobject");
            this.depth--;
            this.state = this.stack.pop() || STATE.VALUE;
            continue;
          } else
            this.stack.push(STATE.CLOSE_OBJECT);
          if (c === Char.doubleQuote)
            this.state = STATE.STRING;
          else
            this._error('Malformed object key should start with "');
          continue;
        case STATE.CLOSE_KEY:
        case STATE.CLOSE_OBJECT:
          if (isWhitespace(c))
            continue;
          if (c === Char.colon) {
            if (this.state === STATE.CLOSE_OBJECT) {
              this.stack.push(STATE.CLOSE_OBJECT);
              this._closeValue("onopenobject");
              this.depth++;
            } else
              this._closeValue("onkey");
            this.state = STATE.VALUE;
          } else if (c === Char.closeBrace) {
            this.emitNode("oncloseobject");
            this.depth--;
            this.state = this.stack.pop() || STATE.VALUE;
          } else if (c === Char.comma) {
            if (this.state === STATE.CLOSE_OBJECT)
              this.stack.push(STATE.CLOSE_OBJECT);
            this._closeValue();
            this.state = STATE.OPEN_KEY;
          } else
            this._error("Bad object");
          continue;
        case STATE.OPEN_ARRAY:
        case STATE.VALUE:
          if (isWhitespace(c))
            continue;
          if (this.state === STATE.OPEN_ARRAY) {
            this.emit("onopenarray");
            this.depth++;
            this.state = STATE.VALUE;
            if (c === Char.closeBracket) {
              this.emit("onclosearray");
              this.depth--;
              this.state = this.stack.pop() || STATE.VALUE;
              continue;
            } else {
              this.stack.push(STATE.CLOSE_ARRAY);
            }
          }
          if (c === Char.doubleQuote)
            this.state = STATE.STRING;
          else if (c === Char.openBrace)
            this.state = STATE.OPEN_OBJECT;
          else if (c === Char.openBracket)
            this.state = STATE.OPEN_ARRAY;
          else if (c === Char.t)
            this.state = STATE.TRUE;
          else if (c === Char.f)
            this.state = STATE.FALSE;
          else if (c === Char.n)
            this.state = STATE.NULL;
          else if (c === Char.minus) {
            this.numberNode += "-";
          } else if (Char._0 <= c && c <= Char._9) {
            this.numberNode += String.fromCharCode(c);
            this.state = STATE.NUMBER_DIGIT;
          } else
            this._error("Bad value");
          continue;
        case STATE.CLOSE_ARRAY:
          if (c === Char.comma) {
            this.stack.push(STATE.CLOSE_ARRAY);
            this._closeValue("onvalue");
            this.state = STATE.VALUE;
          } else if (c === Char.closeBracket) {
            this.emitNode("onclosearray");
            this.depth--;
            this.state = this.stack.pop() || STATE.VALUE;
          } else if (isWhitespace(c))
            continue;
          else
            this._error("Bad array");
          continue;
        case STATE.STRING:
          if (this.textNode === void 0) {
            this.textNode = "";
          }
          let starti = i - 1;
          let slashed = this.slashed;
          let unicodeI = this.unicodeI;
          STRING_BIGLOOP:
            while (true) {
              while (unicodeI > 0) {
                this.unicodeS += String.fromCharCode(c);
                c = chunk.charCodeAt(i++);
                this.position++;
                if (unicodeI === 4) {
                  this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16));
                  unicodeI = 0;
                  starti = i - 1;
                } else {
                  unicodeI++;
                }
                if (!c)
                  break STRING_BIGLOOP;
              }
              if (c === Char.doubleQuote && !slashed) {
                this.state = this.stack.pop() || STATE.VALUE;
                this.textNode += chunk.substring(starti, i - 1);
                this.position += i - 1 - starti;
                break;
              }
              if (c === Char.backslash && !slashed) {
                slashed = true;
                this.textNode += chunk.substring(starti, i - 1);
                this.position += i - 1 - starti;
                c = chunk.charCodeAt(i++);
                this.position++;
                if (!c)
                  break;
              }
              if (slashed) {
                slashed = false;
                if (c === Char.n) {
                  this.textNode += "\n";
                } else if (c === Char.r) {
                  this.textNode += "\r";
                } else if (c === Char.t) {
                  this.textNode += "	";
                } else if (c === Char.f) {
                  this.textNode += "\f";
                } else if (c === Char.b) {
                  this.textNode += "\b";
                } else if (c === Char.u) {
                  unicodeI = 1;
                  this.unicodeS = "";
                } else {
                  this.textNode += String.fromCharCode(c);
                }
                c = chunk.charCodeAt(i++);
                this.position++;
                starti = i - 1;
                if (!c)
                  break;
                else
                  continue;
              }
              stringTokenPattern.lastIndex = i;
              const reResult = stringTokenPattern.exec(chunk);
              if (reResult === null) {
                i = chunk.length + 1;
                this.textNode += chunk.substring(starti, i - 1);
                this.position += i - 1 - starti;
                break;
              }
              i = reResult.index + 1;
              c = chunk.charCodeAt(reResult.index);
              if (!c) {
                this.textNode += chunk.substring(starti, i - 1);
                this.position += i - 1 - starti;
                break;
              }
            }
          this.slashed = slashed;
          this.unicodeI = unicodeI;
          continue;
        case STATE.TRUE:
          if (c === Char.r)
            this.state = STATE.TRUE2;
          else
            this._error(`Invalid true started with t${c}`);
          continue;
        case STATE.TRUE2:
          if (c === Char.u)
            this.state = STATE.TRUE3;
          else
            this._error(`Invalid true started with tr${c}`);
          continue;
        case STATE.TRUE3:
          if (c === Char.e) {
            this.emit("onvalue", true);
            this.state = this.stack.pop() || STATE.VALUE;
          } else
            this._error(`Invalid true started with tru${c}`);
          continue;
        case STATE.FALSE:
          if (c === Char.a)
            this.state = STATE.FALSE2;
          else
            this._error(`Invalid false started with f${c}`);
          continue;
        case STATE.FALSE2:
          if (c === Char.l)
            this.state = STATE.FALSE3;
          else
            this._error(`Invalid false started with fa${c}`);
          continue;
        case STATE.FALSE3:
          if (c === Char.s)
            this.state = STATE.FALSE4;
          else
            this._error(`Invalid false started with fal${c}`);
          continue;
        case STATE.FALSE4:
          if (c === Char.e) {
            this.emit("onvalue", false);
            this.state = this.stack.pop() || STATE.VALUE;
          } else
            this._error(`Invalid false started with fals${c}`);
          continue;
        case STATE.NULL:
          if (c === Char.u)
            this.state = STATE.NULL2;
          else
            this._error(`Invalid null started with n${c}`);
          continue;
        case STATE.NULL2:
          if (c === Char.l)
            this.state = STATE.NULL3;
          else
            this._error(`Invalid null started with nu${c}`);
          continue;
        case STATE.NULL3:
          if (c === Char.l) {
            this.emit("onvalue", null);
            this.state = this.stack.pop() || STATE.VALUE;
          } else
            this._error(`Invalid null started with nul${c}`);
          continue;
        case STATE.NUMBER_DECIMAL_POINT:
          if (c === Char.period) {
            this.numberNode += ".";
            this.state = STATE.NUMBER_DIGIT;
          } else
            this._error("Leading zero not followed by .");
          continue;
        case STATE.NUMBER_DIGIT:
          if (Char._0 <= c && c <= Char._9)
            this.numberNode += String.fromCharCode(c);
          else if (c === Char.period) {
            if (this.numberNode.indexOf(".") !== -1)
              this._error("Invalid number has two dots");
            this.numberNode += ".";
          } else if (c === Char.e || c === Char.E) {
            if (this.numberNode.indexOf("e") !== -1 || this.numberNode.indexOf("E") !== -1)
              this._error("Invalid number has two exponential");
            this.numberNode += "e";
          } else if (c === Char.plus || c === Char.minus) {
            if (!(p === Char.e || p === Char.E))
              this._error("Invalid symbol in number");
            this.numberNode += String.fromCharCode(c);
          } else {
            this._closeNumber();
            i--;
            this.state = this.stack.pop() || STATE.VALUE;
          }
          continue;
        default:
          this._error(`Unknown state: ${this.state}`);
      }
    }
    if (this.position >= this.bufferCheckPosition) {
      checkBufferLength(this);
    }
    this.emit("onchunkparsed");
    return this;
  }
  _closeValue(event = "onvalue") {
    if (this.textNode !== void 0) {
      this.emit(event, this.textNode);
    }
    this.textNode = void 0;
  }
  _closeNumber() {
    if (this.numberNode)
      this.emit("onvalue", parseFloat(this.numberNode));
    this.numberNode = "";
  }
  _error(message = "") {
    this._closeValue();
    message += `
Line: ${this.line}
Column: ${this.column}
Char: ${this.c}`;
    const error = new Error(message);
    this.error = error;
    this.emit("onerror", error);
  }
};
function isWhitespace(c) {
  return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;
}
function checkBufferLength(parser) {
  const maxAllowed = Math.max(MAX_BUFFER_LENGTH, 10);
  let maxActual = 0;
  for (const buffer of ["textNode", "numberNode"]) {
    const len = parser[buffer] === void 0 ? 0 : parser[buffer].length;
    if (len > maxAllowed) {
      switch (buffer) {
        case "text":
          break;
        default:
          parser._error(`Max buffer length exceeded: ${buffer}`);
      }
    }
    maxActual = Math.max(maxActual, len);
  }
  parser.bufferCheckPosition = MAX_BUFFER_LENGTH - maxActual + parser.position;
}

// node_modules/@loaders.gl/json/dist/lib/jsonpath/jsonpath.js
var JSONPath = class _JSONPath {
  constructor(path = null) {
    __publicField(this, "path");
    this.path = ["$"];
    if (path instanceof _JSONPath) {
      this.path = [...path.path];
      return;
    }
    if (Array.isArray(path)) {
      this.path.push(...path);
      return;
    }
    if (typeof path === "string") {
      this.path = path.split(".");
      if (this.path[0] !== "$") {
        throw new Error("JSONPaths must start with $");
      }
    }
  }
  clone() {
    return new _JSONPath(this);
  }
  toString() {
    return this.path.join(".");
  }
  push(name) {
    this.path.push(name);
  }
  pop() {
    return this.path.pop();
  }
  set(name) {
    this.path[this.path.length - 1] = name;
  }
  equals(other) {
    if (!this || !other || this.path.length !== other.path.length) {
      return false;
    }
    for (let i = 0; i < this.path.length; ++i) {
      if (this.path[i] !== other.path[i]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Sets the value pointed at by path
   * TODO - handle root path
   * @param object
   * @param value
   */
  setFieldAtPath(object, value) {
    const path = [...this.path];
    path.shift();
    const field = path.pop();
    for (const component of path) {
      object = object[component];
    }
    object[field] = value;
  }
  /**
   * Gets the value pointed at by path
   * TODO - handle root path
   * @param object
   */
  getFieldAtPath(object) {
    const path = [...this.path];
    path.shift();
    const field = path.pop();
    for (const component of path) {
      object = object[component];
    }
    return object[field];
  }
};

// node_modules/@loaders.gl/json/dist/lib/json-parser/json-parser.js
var JSONParser = class {
  constructor(options) {
    __publicField(this, "parser");
    __publicField(this, "result");
    __publicField(this, "previousStates", []);
    __publicField(this, "currentState", Object.freeze({ container: [], key: null }));
    __publicField(this, "jsonpath", new JSONPath());
    this.reset();
    this.parser = new ClarinetParser({
      onready: () => {
        this.jsonpath = new JSONPath();
        this.previousStates.length = 0;
        this.currentState.container.length = 0;
      },
      onopenobject: (name) => {
        this._openObject({});
        if (typeof name !== "undefined") {
          this.parser.emit("onkey", name);
        }
      },
      onkey: (name) => {
        this.jsonpath.set(name);
        this.currentState.key = name;
      },
      oncloseobject: () => {
        this._closeObject();
      },
      onopenarray: () => {
        this._openArray();
      },
      onclosearray: () => {
        this._closeArray();
      },
      onvalue: (value) => {
        this._pushOrSet(value);
      },
      onerror: (error) => {
        throw error;
      },
      onend: () => {
        this.result = this.currentState.container.pop();
      },
      ...options
    });
  }
  reset() {
    this.result = void 0;
    this.previousStates = [];
    this.currentState = Object.freeze({ container: [], key: null });
    this.jsonpath = new JSONPath();
  }
  write(chunk) {
    this.parser.write(chunk);
  }
  close() {
    this.parser.close();
  }
  // PRIVATE METHODS
  _pushOrSet(value) {
    const { container, key } = this.currentState;
    if (key !== null) {
      container[key] = value;
      this.currentState.key = null;
    } else {
      container.push(value);
    }
  }
  _openArray(newContainer = []) {
    this.jsonpath.push(null);
    this._pushOrSet(newContainer);
    this.previousStates.push(this.currentState);
    this.currentState = { container: newContainer, isArray: true, key: null };
  }
  _closeArray() {
    this.jsonpath.pop();
    this.currentState = this.previousStates.pop();
  }
  _openObject(newContainer = {}) {
    this.jsonpath.push(null);
    this._pushOrSet(newContainer);
    this.previousStates.push(this.currentState);
    this.currentState = { container: newContainer, isArray: false, key: null };
  }
  _closeObject() {
    this.jsonpath.pop();
    this.currentState = this.previousStates.pop();
  }
};

// node_modules/@loaders.gl/json/dist/lib/json-parser/streaming-json-parser.js
var StreamingJSONParser = class extends JSONParser {
  constructor(options = {}) {
    super({
      onopenarray: () => {
        if (!this.streamingArray) {
          if (this._matchJSONPath()) {
            this.streamingJsonPath = this.getJsonPath().clone();
            this.streamingArray = [];
            this._openArray(this.streamingArray);
            return;
          }
        }
        this._openArray();
      },
      // Redefine onopenarray to inject value for top-level object
      onopenobject: (name) => {
        if (!this.topLevelObject) {
          this.topLevelObject = {};
          this._openObject(this.topLevelObject);
        } else {
          this._openObject({});
        }
        if (typeof name !== "undefined") {
          this.parser.emit("onkey", name);
        }
      }
    });
    __publicField(this, "jsonPaths");
    __publicField(this, "streamingJsonPath", null);
    __publicField(this, "streamingArray", null);
    __publicField(this, "topLevelObject", null);
    const jsonpaths = options.jsonpaths || [];
    this.jsonPaths = jsonpaths.map((jsonpath) => new JSONPath(jsonpath));
  }
  /**
   * write REDEFINITION
   * - super.write() chunk to parser
   * - get the contents (so far) of "topmost-level" array as batch of rows
   * - clear top-level array
   * - return the batch of rows\
   */
  write(chunk) {
    super.write(chunk);
    let array = [];
    if (this.streamingArray) {
      array = [...this.streamingArray];
      this.streamingArray.length = 0;
    }
    return array;
  }
  /**
   * Returns a partially formed result object
   * Useful for returning the "wrapper" object when array is not top level
   * e.g. GeoJSON
   */
  getPartialResult() {
    return this.topLevelObject;
  }
  getStreamingJsonPath() {
    return this.streamingJsonPath;
  }
  getStreamingJsonPathAsString() {
    return this.streamingJsonPath && this.streamingJsonPath.toString();
  }
  getJsonPath() {
    return this.jsonpath;
  }
  // PRIVATE METHODS
  /**
   * Checks is this.getJsonPath matches the jsonpaths provided in options
   */
  _matchJSONPath() {
    const currentPath = this.getJsonPath();
    if (this.jsonPaths.length === 0) {
      return true;
    }
    for (const jsonPath of this.jsonPaths) {
      if (jsonPath.equals(currentPath)) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/@loaders.gl/json/dist/lib/parsers/parse-json-in-batches.js
async function* parseJSONInBatches(binaryAsyncIterator, options) {
  var _a;
  const asyncIterator = makeTextDecoderIterator(binaryAsyncIterator);
  const { metadata } = options;
  const { jsonpaths } = options.json || {};
  let isFirstChunk = true;
  const schema = null;
  const tableBatchBuilder = new TableBatchBuilder(schema, options);
  const parser = new StreamingJSONParser({ jsonpaths });
  for await (const chunk of asyncIterator) {
    const rows = parser.write(chunk);
    const jsonpath2 = rows.length > 0 && parser.getStreamingJsonPathAsString();
    if (rows.length > 0 && isFirstChunk) {
      if (metadata) {
        const initialBatch = {
          // Common fields
          shape: ((_a = options == null ? void 0 : options.json) == null ? void 0 : _a.shape) || "array-row-table",
          batchType: "partial-result",
          data: [],
          length: 0,
          bytesUsed: 0,
          // JSON additions
          container: parser.getPartialResult(),
          jsonpath: jsonpath2
        };
        yield initialBatch;
      }
      isFirstChunk = false;
    }
    for (const row of rows) {
      tableBatchBuilder.addRow(row);
      const batch3 = tableBatchBuilder.getFullBatch({ jsonpath: jsonpath2 });
      if (batch3) {
        yield batch3;
      }
    }
    tableBatchBuilder.chunkComplete(chunk);
    const batch2 = tableBatchBuilder.getFullBatch({ jsonpath: jsonpath2 });
    if (batch2) {
      yield batch2;
    }
  }
  const jsonpath = parser.getStreamingJsonPathAsString();
  const batch = tableBatchBuilder.getFinalBatch({ jsonpath });
  if (batch) {
    yield batch;
  }
  if (metadata) {
    const finalBatch = {
      shape: "json",
      batchType: "final-result",
      container: parser.getPartialResult(),
      jsonpath: parser.getStreamingJsonPathAsString(),
      /** Data Just to avoid crashing? */
      data: [],
      length: 0
      // schema: null
    };
    yield finalBatch;
  }
}
function rebuildJsonObject(batch, data) {
  assert(batch.batchType === "final-result");
  if (batch.jsonpath === "$") {
    return data;
  }
  if (batch.jsonpath && batch.jsonpath.length > 1) {
    const topLevelObject = batch.container;
    const streamingPath = new JSONPath(batch.jsonpath);
    streamingPath.setFieldAtPath(topLevelObject, data);
    return topLevelObject;
  }
  return batch.container;
}

// node_modules/@loaders.gl/json/dist/json-loader.js
var VERSION = true ? "4.3.2" : "latest";
var JSONLoader = {
  dataType: null,
  batchType: null,
  name: "JSON",
  id: "json",
  module: "json",
  version: VERSION,
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json"],
  category: "table",
  text: true,
  options: {
    json: {
      shape: void 0,
      table: false,
      jsonpaths: []
      // batchSize: 'auto'
    }
  },
  parse,
  parseTextSync,
  parseInBatches
};
async function parse(arrayBuffer, options) {
  return parseTextSync(new TextDecoder().decode(arrayBuffer), options);
}
function parseTextSync(text, options) {
  const jsonOptions = { ...options, json: { ...JSONLoader.options.json, ...options == null ? void 0 : options.json } };
  return parseJSONSync(text, jsonOptions);
}
function parseInBatches(asyncIterator, options) {
  const jsonOptions = { ...options, json: { ...JSONLoader.options.json, ...options == null ? void 0 : options.json } };
  return parseJSONInBatches(asyncIterator, jsonOptions);
}

// node_modules/@loaders.gl/json/dist/lib/parsers/parse-ndjson.js
function parseNDJSONSync(ndjsonText) {
  const lines = ndjsonText.trim().split("\n");
  const parsedLines = lines.map((line, counter) => {
    try {
      return JSON.parse(line);
    } catch (error) {
      throw new Error(`NDJSONLoader: failed to parse JSON on line ${counter + 1}`);
    }
  });
  return makeTableFromData(parsedLines);
}

// node_modules/@loaders.gl/json/dist/lib/parsers/parse-ndjson-in-batches.js
async function* parseNDJSONInBatches(binaryAsyncIterator, options) {
  const textIterator = makeTextDecoderIterator(binaryAsyncIterator);
  const lineIterator = makeLineIterator(textIterator);
  const numberedLineIterator = makeNumberedLineIterator(lineIterator);
  const schema = null;
  const shape = "row-table";
  const tableBatchBuilder = new TableBatchBuilder(schema, {
    ...options,
    shape
  });
  for await (const { counter, line } of numberedLineIterator) {
    try {
      const row = JSON.parse(line);
      tableBatchBuilder.addRow(row);
      tableBatchBuilder.chunkComplete(line);
      const batch2 = tableBatchBuilder.getFullBatch();
      if (batch2) {
        yield batch2;
      }
    } catch (error) {
      throw new Error(`NDJSONLoader: failed to parse JSON on line ${counter}`);
    }
  }
  const batch = tableBatchBuilder.getFinalBatch();
  if (batch) {
    yield batch;
  }
}

// node_modules/@loaders.gl/json/dist/ndjson-loader.js
var VERSION2 = true ? "4.3.2" : "latest";
var NDJSONLoader = {
  dataType: null,
  batchType: null,
  name: "NDJSON",
  id: "ndjson",
  module: "json",
  version: VERSION2,
  extensions: ["ndjson", "jsonl"],
  mimeTypes: [
    "application/x-ndjson",
    "application/jsonlines",
    // https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html#cm-batch
    "application/json-seq"
  ],
  category: "table",
  text: true,
  parse: async (arrayBuffer) => parseNDJSONSync(new TextDecoder().decode(arrayBuffer)),
  parseTextSync: parseNDJSONSync,
  parseInBatches: parseNDJSONInBatches,
  options: {}
};

// node_modules/@loaders.gl/json/dist/lib/encoders/json-encoder.js
function encodeTableAsJSON(table, options) {
  var _a;
  const shape = ((_a = options == null ? void 0 : options.json) == null ? void 0 : _a.shape) || "object-row-table";
  const strings = [];
  const rowIterator = makeRowIterator(table, shape);
  for (const row of rowIterator) {
    strings.push(JSON.stringify(row));
  }
  return `[${strings.join(",")}]`;
}

// node_modules/@loaders.gl/json/dist/json-writer.js
var JSONWriter = {
  id: "json",
  version: "latest",
  module: "json",
  name: "JSON",
  extensions: ["json"],
  mimeTypes: ["application/json"],
  options: {},
  text: true,
  encode: async (table, options) => new TextEncoder().encode(encodeTableAsJSON(table, options)).buffer,
  encodeTextSync: (table, options) => encodeTableAsJSON(table, options)
};

// node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js
function flatGeojsonToBinary(features, geometryInfo, options) {
  const propArrayTypes = extractNumericPropTypes(features);
  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
  return fillArrays(features, {
    propArrayTypes,
    ...geometryInfo
  }, {
    numericPropKeys: options && options.numericPropKeys || numericPropKeys,
    PositionDataType: options ? options.PositionDataType : Float32Array,
    triangulate: options ? options.triangulate : true
  });
}
function extractNumericPropTypes(features) {
  const propArrayTypes = {};
  for (const feature of features) {
    if (feature.properties) {
      for (const key in feature.properties) {
        const val = feature.properties[key];
        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
      }
    }
  }
  return propArrayTypes;
}
function fillArrays(features, geometryInfo, options) {
  const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;
  const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
  const hasGlobalId = features[0] && "id" in features[0];
  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    type: "Point",
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const lines = {
    type: "LineString",
    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const polygons = {
    type: "Polygon",
    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  if (triangulate) {
    polygons.triangles = [];
  }
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      const T = propArrayTypes[propName];
      object.numericProps[propName] = new T(object.positions.length / coordLength);
    }
  }
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };
  for (const feature of features) {
    const geometry = feature.geometry;
    const properties = feature.properties || {};
    switch (geometry.type) {
      case "Point":
        handlePoint(geometry, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          points.fields.push({ id: feature.id });
        }
        indexMap.pointFeature++;
        break;
      case "LineString":
        handleLineString(geometry, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          lines.fields.push({ id: feature.id });
        }
        indexMap.lineFeature++;
        break;
      case "Polygon":
        handlePolygon(geometry, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          polygons.fields.push({ id: feature.id });
        }
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error("Invalid geometry type");
    }
    indexMap.feature++;
  }
  return makeAccessorObjects(points, lines, polygons, coordLength);
}
function handlePoint(geometry, points, indexMap, coordLength, properties) {
  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  indexMap.pointPosition += nPositions;
}
function handleLineString(geometry, lines, indexMap, coordLength, properties) {
  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
  for (let i = 0, il = geometry.indices.length; i < il; ++i) {
    const start = geometry.indices[i];
    const end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];
    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
    indexMap.linePosition += (end - start) / coordLength;
  }
}
function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
    const startPosition = indexMap.polygonPosition;
    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
    const areas = geometry.areas[l];
    const indices = geometry.indices[l];
    const nextIndices = geometry.indices[l + 1];
    for (let i = 0, il = indices.length; i < il; ++i) {
      const start = indices[i];
      const end = i === il - 1 ? (
        // last line, so either read to:
        nextIndices === void 0 ? geometry.data.length : nextIndices[0]
      ) : indices[i + 1];
      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
      indexMap.polygonPosition += (end - start) / coordLength;
    }
    const endPosition = indexMap.polygonPosition;
    triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
  }
}
function triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {
  if (!polygons.triangles) {
    return;
  }
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.subarray(start, end);
  const offset = indices[0];
  const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
  const triangles = earcut(polygonPositions, holes, coordLength, areas);
  for (let t = 0, tl = triangles.length; t < tl; ++t) {
    polygons.triangles.push(startPosition + triangles[t]);
  }
}
function wrapProps(obj, size) {
  const returnObj = {};
  for (const key in obj) {
    returnObj[key] = { value: obj[key], size };
  }
  return returnObj;
}
function makeAccessorObjects(points, lines, polygons, coordLength) {
  const binaryFeatures = {
    shape: "binary-feature-collection",
    points: {
      ...points,
      positions: { value: points.positions, size: coordLength },
      globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
      featureIds: { value: points.featureIds, size: 1 },
      numericProps: wrapProps(points.numericProps, 1)
    },
    lines: {
      ...lines,
      positions: { value: lines.positions, size: coordLength },
      pathIndices: { value: lines.pathIndices, size: 1 },
      globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
      featureIds: { value: lines.featureIds, size: 1 },
      numericProps: wrapProps(lines.numericProps, 1)
    },
    polygons: {
      ...polygons,
      positions: { value: polygons.positions, size: coordLength },
      polygonIndices: { value: polygons.polygonIndices, size: 1 },
      primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
      globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
      featureIds: { value: polygons.featureIds, size: 1 },
      numericProps: wrapProps(polygons.numericProps, 1)
    }
    // triangles not expected
  };
  if (binaryFeatures.polygons && polygons.triangles) {
    binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
  }
  return binaryFeatures;
}
function fillNumericProperties(object, properties, index, length) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      const value = properties[numericPropName];
      object.numericProps[numericPropName].fill(value, index, index + length);
    }
  }
}
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}
function deduceArrayType(x, constructor) {
  if (constructor === Array || !Number.isFinite(x)) {
    return Array;
  }
  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;
}

// node_modules/@loaders.gl/gis/dist/lib/binary-features/extract-geometry-info.js
function extractGeometryInfo(features) {
  let pointPositionsCount = 0;
  let pointFeaturesCount = 0;
  let linePositionsCount = 0;
  let linePathsCount = 0;
  let lineFeaturesCount = 0;
  let polygonPositionsCount = 0;
  let polygonObjectsCount = 0;
  let polygonRingsCount = 0;
  let polygonFeaturesCount = 0;
  const coordLengths = /* @__PURE__ */ new Set();
  for (const feature of features) {
    const geometry = feature.geometry;
    switch (geometry.type) {
      case "Point":
        pointFeaturesCount++;
        pointPositionsCount++;
        coordLengths.add(geometry.coordinates.length);
        break;
      case "MultiPoint":
        pointFeaturesCount++;
        pointPositionsCount += geometry.coordinates.length;
        for (const point of geometry.coordinates) {
          coordLengths.add(point.length);
        }
        break;
      case "LineString":
        lineFeaturesCount++;
        linePositionsCount += geometry.coordinates.length;
        linePathsCount++;
        for (const coord of geometry.coordinates) {
          coordLengths.add(coord.length);
        }
        break;
      case "MultiLineString":
        lineFeaturesCount++;
        for (const line of geometry.coordinates) {
          linePositionsCount += line.length;
          linePathsCount++;
          for (const coord of line) {
            coordLengths.add(coord.length);
          }
        }
        break;
      case "Polygon":
        polygonFeaturesCount++;
        polygonObjectsCount++;
        polygonRingsCount += geometry.coordinates.length;
        const flattened = geometry.coordinates.flat();
        polygonPositionsCount += flattened.length;
        for (const coord of flattened) {
          coordLengths.add(coord.length);
        }
        break;
      case "MultiPolygon":
        polygonFeaturesCount++;
        for (const polygon of geometry.coordinates) {
          polygonObjectsCount++;
          polygonRingsCount += polygon.length;
          const flattened2 = polygon.flat();
          polygonPositionsCount += flattened2.length;
          for (const coord of flattened2) {
            coordLengths.add(coord.length);
          }
        }
        break;
      default:
        throw new Error(`Unsupported geometry type: ${geometry.type}`);
    }
  }
  return {
    coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,
    pointPositionsCount,
    pointFeaturesCount,
    linePositionsCount,
    linePathsCount,
    lineFeaturesCount,
    polygonPositionsCount,
    polygonObjectsCount,
    polygonRingsCount,
    polygonFeaturesCount
  };
}

// node_modules/@loaders.gl/gis/dist/lib/binary-features/geojson-to-flat-geojson.js
function geojsonToFlatGeojson(features, options = { coordLength: 2, fixRingWinding: true }) {
  return features.map((feature) => flattenFeature(feature, options));
}
function flattenPoint(coordinates, data, indices, options) {
  indices.push(data.length);
  data.push(...coordinates);
  for (let i = coordinates.length; i < options.coordLength; i++) {
    data.push(0);
  }
}
function flattenLineString(coordinates, data, indices, options) {
  indices.push(data.length);
  for (const c of coordinates) {
    data.push(...c);
    for (let i = c.length; i < options.coordLength; i++) {
      data.push(0);
    }
  }
}
function flattenPolygon(coordinates, data, indices, areas, options) {
  let count = 0;
  const ringAreas = [];
  const polygons = [];
  for (const lineString of coordinates) {
    const lineString2d = lineString.map((p) => p.slice(0, 2));
    let area = getPolygonSignedArea(lineString2d.flat());
    const ccw = area < 0;
    if (options.fixRingWinding && (count === 0 && !ccw || count > 0 && ccw)) {
      lineString.reverse();
      area = -area;
    }
    ringAreas.push(area);
    flattenLineString(lineString, data, polygons, options);
    count++;
  }
  if (count > 0) {
    areas.push(ringAreas);
    indices.push(polygons);
  }
}
function flattenFeature(feature, options) {
  const { geometry } = feature;
  if (geometry.type === "GeometryCollection") {
    throw new Error("GeometryCollection type not supported");
  }
  const data = [];
  const indices = [];
  let areas;
  let type;
  switch (geometry.type) {
    case "Point":
      type = "Point";
      flattenPoint(geometry.coordinates, data, indices, options);
      break;
    case "MultiPoint":
      type = "Point";
      geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));
      break;
    case "LineString":
      type = "LineString";
      flattenLineString(geometry.coordinates, data, indices, options);
      break;
    case "MultiLineString":
      type = "LineString";
      geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));
      break;
    case "Polygon":
      type = "Polygon";
      areas = [];
      flattenPolygon(geometry.coordinates, data, indices, areas, options);
      break;
    case "MultiPolygon":
      type = "Polygon";
      areas = [];
      geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));
      break;
    default:
      throw new Error(`Unknown type: ${type}`);
  }
  return { ...feature, geometry: { type, indices, data, areas } };
}

// node_modules/@loaders.gl/gis/dist/lib/binary-features/geojson-to-binary.js
function geojsonToBinary(features, options = { fixRingWinding: true, triangulate: true }) {
  const geometryInfo = extractGeometryInfo(features);
  const coordLength = geometryInfo.coordLength;
  const { fixRingWinding } = options;
  const flatFeatures = geojsonToFlatGeojson(features, { coordLength, fixRingWinding });
  return flatGeojsonToBinary(flatFeatures, geometryInfo, {
    numericPropKeys: options.numericPropKeys,
    PositionDataType: options.PositionDataType || Float32Array,
    triangulate: options.triangulate
  });
}

// node_modules/@loaders.gl/json/dist/geojson-loader.js
var VERSION3 = true ? "4.3.2" : "latest";
var GeoJSONWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "GeoJSON",
  id: "geojson",
  module: "geojson",
  version: VERSION3,
  worker: true,
  extensions: ["geojson"],
  mimeTypes: ["application/geo+json"],
  category: "geometry",
  text: true,
  options: {
    geojson: {
      shape: "geojson-table"
    },
    json: {
      shape: "object-row-table",
      jsonpaths: ["$", "$.features"]
    },
    gis: {
      format: "geojson"
    }
  }
};
var GeoJSONLoader = {
  ...GeoJSONWorkerLoader,
  // @ts-expect-error
  parse: parse2,
  // @ts-expect-error
  parseTextSync: parseTextSync2,
  parseInBatches: parseInBatches2
};
async function parse2(arrayBuffer, options) {
  return parseTextSync2(new TextDecoder().decode(arrayBuffer), options);
}
function parseTextSync2(text, options) {
  options = { ...GeoJSONLoader.options, ...options };
  options.geojson = { ...GeoJSONLoader.options.geojson, ...options.geojson };
  options.gis = options.gis || {};
  let geojson;
  try {
    geojson = JSON.parse(text);
  } catch {
    geojson = {};
  }
  const table = {
    shape: "geojson-table",
    // TODO - deduce schema from geojson
    // TODO check that parsed data is of type FeatureCollection
    type: "FeatureCollection",
    features: (geojson == null ? void 0 : geojson.features) || []
  };
  switch (options.gis.format) {
    case "binary":
      return geojsonToBinary(table.features);
    default:
      return table;
  }
}
function parseInBatches2(asyncIterator, options) {
  options = { ...GeoJSONLoader.options, ...options };
  options.json = { ...GeoJSONLoader.options.geojson, ...options.geojson };
  const geojsonIterator = parseJSONInBatches(asyncIterator, options);
  switch (options.gis.format) {
    case "binary":
      return makeBinaryGeometryIterator(geojsonIterator);
    default:
      return geojsonIterator;
  }
}
async function* makeBinaryGeometryIterator(geojsonIterator) {
  for await (const batch of geojsonIterator) {
    batch.data = geojsonToBinary(batch.data);
    yield batch;
  }
}

// node_modules/@loaders.gl/json/dist/lib/encoder-utils/encode-utils.js
function detectGeometryColumnIndex(table) {
  var _a;
  const geometryIndex = ((_a = table.schema) == null ? void 0 : _a.fields.findIndex((field) => field.name === "geometry")) ?? -1;
  if (geometryIndex > -1) {
    return geometryIndex;
  }
  if (getTableLength(table) > 0) {
    const row = getTableRowAsArray(table, 0);
    for (let columnIndex = 0; columnIndex < getTableNumCols(table); columnIndex++) {
      const value = row == null ? void 0 : row[columnIndex];
      if (value && typeof value === "object") {
        return columnIndex;
      }
    }
  }
  throw new Error("Failed to detect geometry column");
}
function getRowPropertyObject(table, row, excludeColumnIndices = []) {
  var _a;
  const properties = {};
  for (let columnIndex = 0; columnIndex < getTableNumCols(table); ++columnIndex) {
    const columnName = (_a = table.schema) == null ? void 0 : _a.fields[columnIndex].name;
    if (columnName && !excludeColumnIndices.includes(columnIndex)) {
      properties[columnName] = row[columnName];
    }
  }
  return properties;
}

// node_modules/@loaders.gl/json/dist/lib/encoder-utils/encode-table-row.js
function encodeTableRow(table, rowIndex, geometryColumnIndex, utf8Encoder) {
  const row = getTableRowAsObject(table, rowIndex);
  if (!row)
    return;
  const featureWithProperties = getFeatureFromRow(table, row, geometryColumnIndex);
  const featureString = JSON.stringify(featureWithProperties);
  utf8Encoder.push(featureString);
}
function getFeatureFromRow(table, row, geometryColumnIndex) {
  var _a;
  const properties = getRowPropertyObject(table, row, [geometryColumnIndex]);
  const columnName = (_a = table.schema) == null ? void 0 : _a.fields[geometryColumnIndex].name;
  let featureOrGeometry = columnName && row[columnName];
  if (!featureOrGeometry) {
    return { type: "Feature", geometry: null, properties };
  }
  if (typeof featureOrGeometry === "string") {
    try {
      featureOrGeometry = JSON.parse(featureOrGeometry);
    } catch (err) {
      throw new Error("Invalid string geometry");
    }
  }
  if (typeof featureOrGeometry !== "object" || typeof (featureOrGeometry == null ? void 0 : featureOrGeometry.type) !== "string") {
    throw new Error("invalid geometry column value");
  }
  if ((featureOrGeometry == null ? void 0 : featureOrGeometry.type) === "Feature") {
    return { ...featureOrGeometry, properties };
  }
  return { type: "Feature", geometry: featureOrGeometry, properties };
}

// node_modules/@loaders.gl/json/dist/lib/encoder-utils/utf8-encoder.js
var Utf8ArrayBufferEncoder = class {
  constructor(chunkSize) {
    __publicField(this, "chunkSize");
    __publicField(this, "strings", []);
    __publicField(this, "totalLength", 0);
    __publicField(this, "textEncoder", new TextEncoder());
    this.chunkSize = chunkSize;
  }
  push(...strings) {
    for (const string of strings) {
      this.strings.push(string);
      this.totalLength += string.length;
    }
  }
  isFull() {
    return this.totalLength >= this.chunkSize;
  }
  getArrayBufferBatch() {
    return this.textEncoder.encode(this.getStringBatch()).buffer;
  }
  getStringBatch() {
    const stringChunk = this.strings.join("");
    this.strings = [];
    this.totalLength = 0;
    return stringChunk;
  }
};

// node_modules/@loaders.gl/json/dist/lib/encoders/geojson-encoder.js
async function* encodeTableAsGeojsonInBatches(batchIterator, inputOpts = {}) {
  const options = { geojson: {}, chunkSize: 1e4, ...inputOpts };
  const utf8Encoder = new Utf8ArrayBufferEncoder(options.chunkSize);
  if (!options.geojson.featureArray) {
    utf8Encoder.push("{\n", '"type": "FeatureCollection",\n', '"features":\n');
  }
  utf8Encoder.push("[");
  let geometryColumn = options.geojson.geometryColumn;
  let isFirstLine = true;
  let start = 0;
  for await (const tableBatch of batchIterator) {
    const end = start + getTableLength(tableBatch);
    if (!geometryColumn) {
      geometryColumn = geometryColumn || detectGeometryColumnIndex(tableBatch);
    }
    for (let rowIndex = start; rowIndex < end; ++rowIndex) {
      if (!isFirstLine) {
        utf8Encoder.push(",");
      }
      utf8Encoder.push("\n");
      isFirstLine = false;
      encodeTableRow(tableBatch, rowIndex, geometryColumn, utf8Encoder);
      if (utf8Encoder.isFull()) {
        yield utf8Encoder.getArrayBufferBatch();
      }
      start = end;
    }
    const arrayBufferBatch = utf8Encoder.getArrayBufferBatch();
    if (arrayBufferBatch.byteLength > 0) {
      yield arrayBufferBatch;
    }
  }
  utf8Encoder.push("\n");
  utf8Encoder.push("]\n");
  if (!options.geojson.featureArray) {
    utf8Encoder.push("}");
  }
  yield utf8Encoder.getArrayBufferBatch();
}

// node_modules/@loaders.gl/json/dist/geojson-writer.js
var GeoJSONWriter = {
  id: "geojson",
  version: "latest",
  module: "geojson",
  name: "GeoJSON",
  extensions: ["geojson"],
  mimeTypes: ["application/geo+json"],
  text: true,
  options: {
    geojson: {
      featureArray: false,
      geometryColumn: null
    }
  },
  async encode(table, options) {
    const tableIterator = [table];
    const batches = encodeTableAsGeojsonInBatches(tableIterator, options);
    return await concatenateArrayBuffersAsync(batches);
  },
  encodeInBatches: (tableIterator, options) => encodeTableAsGeojsonInBatches(tableIterator, options)
};
export {
  JSONLoader,
  JSONWriter,
  NDJSONLoader,
  ClarinetParser as _ClarinetParser,
  GeoJSONLoader as _GeoJSONLoader,
  GeoJSONWorkerLoader as _GeoJSONWorkerLoader,
  GeoJSONWriter as _GeoJSONWriter,
  JSONPath as _JSONPath,
  rebuildJsonObject as _rebuildJsonObject
};
//# sourceMappingURL=@loaders__gl_json.js.map
