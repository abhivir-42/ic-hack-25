{
  "version": 3,
  "sources": ["../../@loaders.gl/json/dist/lib/parsers/parse-json.js", "../../@loaders.gl/json/dist/lib/clarinet/clarinet.js", "../../@loaders.gl/json/dist/lib/jsonpath/jsonpath.js", "../../@loaders.gl/json/dist/lib/json-parser/json-parser.js", "../../@loaders.gl/json/dist/lib/json-parser/streaming-json-parser.js", "../../@loaders.gl/json/dist/lib/parsers/parse-json-in-batches.js", "../../@loaders.gl/json/dist/json-loader.js", "../../@loaders.gl/json/dist/lib/parsers/parse-ndjson.js", "../../@loaders.gl/json/dist/lib/parsers/parse-ndjson-in-batches.js", "../../@loaders.gl/json/dist/ndjson-loader.js", "../../@loaders.gl/json/dist/lib/encoders/json-encoder.js", "../../@loaders.gl/json/dist/json-writer.js", "../../@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js", "../../@loaders.gl/gis/dist/lib/binary-features/extract-geometry-info.js", "../../@loaders.gl/gis/dist/lib/binary-features/geojson-to-flat-geojson.js", "../../@loaders.gl/gis/dist/lib/binary-features/geojson-to-binary.js", "../../@loaders.gl/json/dist/geojson-loader.js", "../../@loaders.gl/json/dist/lib/encoder-utils/encode-utils.js", "../../@loaders.gl/json/dist/lib/encoder-utils/encode-table-row.js", "../../@loaders.gl/json/dist/lib/encoder-utils/utf8-encoder.js", "../../@loaders.gl/json/dist/lib/encoders/geojson-encoder.js", "../../@loaders.gl/json/dist/geojson-writer.js"],
  "sourcesContent": ["// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { makeTableFromData } from '@loaders.gl/schema';\nexport function parseJSONSync(jsonText, options) {\n    try {\n        const json = JSON.parse(jsonText);\n        if (options.json?.table) {\n            const data = getFirstArray(json) || json;\n            return makeTableFromData(data);\n        }\n        return json;\n    }\n    catch (error) {\n        throw new Error('JSONLoader: failed to parse JSON');\n    }\n}\nfunction getFirstArray(json) {\n    if (Array.isArray(json)) {\n        return json;\n    }\n    if (json && typeof json === 'object') {\n        for (const value of Object.values(json)) {\n            const array = getFirstArray(value);\n            if (array) {\n                return array;\n            }\n        }\n    }\n    return null;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT AND BSD\n// Copyright (c) vis.gl contributors\n// This is a fork of the clarinet library, originally BSD license (see LICENSE file)\n// loaders.gl changes:\n// - typescript port\n// Removes the MAX_BUFFER_LENGTH, originally set to 64 * 1024\nconst MAX_BUFFER_LENGTH = Number.MAX_SAFE_INTEGER;\n// const DEBUG = false;\nvar STATE;\n(function (STATE) {\n    STATE[STATE[\"BEGIN\"] = 0] = \"BEGIN\";\n    STATE[STATE[\"VALUE\"] = 1] = \"VALUE\";\n    STATE[STATE[\"OPEN_OBJECT\"] = 2] = \"OPEN_OBJECT\";\n    STATE[STATE[\"CLOSE_OBJECT\"] = 3] = \"CLOSE_OBJECT\";\n    STATE[STATE[\"OPEN_ARRAY\"] = 4] = \"OPEN_ARRAY\";\n    STATE[STATE[\"CLOSE_ARRAY\"] = 5] = \"CLOSE_ARRAY\";\n    STATE[STATE[\"TEXT_ESCAPE\"] = 6] = \"TEXT_ESCAPE\";\n    STATE[STATE[\"STRING\"] = 7] = \"STRING\";\n    STATE[STATE[\"BACKSLASH\"] = 8] = \"BACKSLASH\";\n    STATE[STATE[\"END\"] = 9] = \"END\";\n    STATE[STATE[\"OPEN_KEY\"] = 10] = \"OPEN_KEY\";\n    STATE[STATE[\"CLOSE_KEY\"] = 11] = \"CLOSE_KEY\";\n    STATE[STATE[\"TRUE\"] = 12] = \"TRUE\";\n    STATE[STATE[\"TRUE2\"] = 13] = \"TRUE2\";\n    STATE[STATE[\"TRUE3\"] = 14] = \"TRUE3\";\n    STATE[STATE[\"FALSE\"] = 15] = \"FALSE\";\n    STATE[STATE[\"FALSE2\"] = 16] = \"FALSE2\";\n    STATE[STATE[\"FALSE3\"] = 17] = \"FALSE3\";\n    STATE[STATE[\"FALSE4\"] = 18] = \"FALSE4\";\n    STATE[STATE[\"NULL\"] = 19] = \"NULL\";\n    STATE[STATE[\"NULL2\"] = 20] = \"NULL2\";\n    STATE[STATE[\"NULL3\"] = 21] = \"NULL3\";\n    STATE[STATE[\"NUMBER_DECIMAL_POINT\"] = 22] = \"NUMBER_DECIMAL_POINT\";\n    STATE[STATE[\"NUMBER_DIGIT\"] = 23] = \"NUMBER_DIGIT\"; // [0-9]\n})(STATE || (STATE = {}));\nconst Char = {\n    tab: 0x09, // \\t\n    lineFeed: 0x0a, // \\n\n    carriageReturn: 0x0d, // \\r\n    space: 0x20, // \" \"\n    doubleQuote: 0x22, // \"\n    plus: 0x2b, // +\n    comma: 0x2c, // ,\n    minus: 0x2d, // -\n    period: 0x2e, // .\n    _0: 0x30, // 0\n    _9: 0x39, // 9\n    colon: 0x3a, // :\n    E: 0x45, // E\n    openBracket: 0x5b, // [\n    backslash: 0x5c, // \\\n    closeBracket: 0x5d, // ]\n    a: 0x61, // a\n    b: 0x62, // b\n    e: 0x65, // e\n    f: 0x66, // f\n    l: 0x6c, // l\n    n: 0x6e, // n\n    r: 0x72, // r\n    s: 0x73, // s\n    t: 0x74, // t\n    u: 0x75, // u\n    openBrace: 0x7b, // {\n    closeBrace: 0x7d // }\n};\nconst stringTokenPattern = /[\\\\\"\\n]/g;\nconst DEFAULT_OPTIONS = {\n    onready: () => { },\n    onopenobject: () => { },\n    onkey: () => { },\n    oncloseobject: () => { },\n    onopenarray: () => { },\n    onclosearray: () => { },\n    onvalue: () => { },\n    onerror: () => { },\n    onend: () => { },\n    onchunkparsed: () => { }\n};\nexport default class ClarinetParser {\n    options = DEFAULT_OPTIONS;\n    bufferCheckPosition = MAX_BUFFER_LENGTH;\n    q = '';\n    c = '';\n    p = '';\n    closed = false;\n    closedRoot = false;\n    sawRoot = false;\n    // tag = null;\n    error = null;\n    state = STATE.BEGIN;\n    stack = [];\n    // mostly just for error reporting\n    position = 0;\n    column = 0;\n    line = 1;\n    slashed = false;\n    unicodeI = 0;\n    unicodeS = null;\n    depth = 0;\n    textNode;\n    numberNode;\n    constructor(options = {}) {\n        this.options = { ...DEFAULT_OPTIONS, ...options };\n        this.textNode = undefined;\n        this.numberNode = '';\n        this.emit('onready');\n    }\n    end() {\n        if (this.state !== STATE.VALUE || this.depth !== 0)\n            this._error('Unexpected end');\n        this._closeValue();\n        this.c = '';\n        this.closed = true;\n        this.emit('onend');\n        return this;\n    }\n    resume() {\n        this.error = null;\n        return this;\n    }\n    close() {\n        return this.write(null);\n    }\n    // protected\n    emit(event, data) {\n        // if (DEBUG) console.log('-- emit', event, data);\n        this.options[event]?.(data, this);\n    }\n    emitNode(event, data) {\n        this._closeValue();\n        this.emit(event, data);\n    }\n    /* eslint-disable no-continue */\n    // eslint-disable-next-line complexity, max-statements\n    write(chunk) {\n        if (this.error) {\n            throw this.error;\n        }\n        if (this.closed) {\n            return this._error('Cannot write after close. Assign an onready handler.');\n        }\n        if (chunk === null) {\n            return this.end();\n        }\n        let i = 0;\n        let c = chunk.charCodeAt(0);\n        let p = this.p;\n        // if (DEBUG) console.log(`write -> [${  chunk  }]`);\n        while (c) {\n            p = c;\n            this.c = c = chunk.charCodeAt(i++);\n            // if chunk doesnt have next, like streaming char by char\n            // this way we need to check if previous is really previous\n            // if not we need to reset to what the this says is the previous\n            // from buffer\n            if (p !== c) {\n                this.p = p;\n            }\n            else {\n                p = this.p;\n            }\n            if (!c)\n                break;\n            // if (DEBUG) console.log(i, c, STATE[this.state]);\n            this.position++;\n            if (c === Char.lineFeed) {\n                this.line++;\n                this.column = 0;\n            }\n            else\n                this.column++;\n            switch (this.state) {\n                case STATE.BEGIN:\n                    if (c === Char.openBrace)\n                        this.state = STATE.OPEN_OBJECT;\n                    else if (c === Char.openBracket)\n                        this.state = STATE.OPEN_ARRAY;\n                    else if (!isWhitespace(c)) {\n                        this._error('Non-whitespace before {[.');\n                    }\n                    continue;\n                case STATE.OPEN_KEY:\n                case STATE.OPEN_OBJECT:\n                    if (isWhitespace(c))\n                        continue;\n                    if (this.state === STATE.OPEN_KEY)\n                        this.stack.push(STATE.CLOSE_KEY);\n                    else if (c === Char.closeBrace) {\n                        this.emit('onopenobject');\n                        this.depth++;\n                        this.emit('oncloseobject');\n                        this.depth--;\n                        this.state = this.stack.pop() || STATE.VALUE;\n                        continue;\n                    }\n                    else\n                        this.stack.push(STATE.CLOSE_OBJECT);\n                    if (c === Char.doubleQuote)\n                        this.state = STATE.STRING;\n                    else\n                        this._error('Malformed object key should start with \"');\n                    continue;\n                case STATE.CLOSE_KEY:\n                case STATE.CLOSE_OBJECT:\n                    if (isWhitespace(c))\n                        continue;\n                    // let event = this.state === STATE.CLOSE_KEY ? 'key' : 'object';\n                    if (c === Char.colon) {\n                        if (this.state === STATE.CLOSE_OBJECT) {\n                            this.stack.push(STATE.CLOSE_OBJECT);\n                            this._closeValue('onopenobject');\n                            this.depth++;\n                        }\n                        else\n                            this._closeValue('onkey');\n                        this.state = STATE.VALUE;\n                    }\n                    else if (c === Char.closeBrace) {\n                        this.emitNode('oncloseobject');\n                        this.depth--;\n                        this.state = this.stack.pop() || STATE.VALUE;\n                    }\n                    else if (c === Char.comma) {\n                        if (this.state === STATE.CLOSE_OBJECT)\n                            this.stack.push(STATE.CLOSE_OBJECT);\n                        this._closeValue();\n                        this.state = STATE.OPEN_KEY;\n                    }\n                    else\n                        this._error('Bad object');\n                    continue;\n                case STATE.OPEN_ARRAY: // after an array there always a value\n                case STATE.VALUE:\n                    if (isWhitespace(c))\n                        continue;\n                    if (this.state === STATE.OPEN_ARRAY) {\n                        this.emit('onopenarray');\n                        this.depth++;\n                        this.state = STATE.VALUE;\n                        if (c === Char.closeBracket) {\n                            this.emit('onclosearray');\n                            this.depth--;\n                            this.state = this.stack.pop() || STATE.VALUE;\n                            continue;\n                        }\n                        else {\n                            this.stack.push(STATE.CLOSE_ARRAY);\n                        }\n                    }\n                    if (c === Char.doubleQuote)\n                        this.state = STATE.STRING;\n                    else if (c === Char.openBrace)\n                        this.state = STATE.OPEN_OBJECT;\n                    else if (c === Char.openBracket)\n                        this.state = STATE.OPEN_ARRAY;\n                    else if (c === Char.t)\n                        this.state = STATE.TRUE;\n                    else if (c === Char.f)\n                        this.state = STATE.FALSE;\n                    else if (c === Char.n)\n                        this.state = STATE.NULL;\n                    else if (c === Char.minus) {\n                        // keep and continue\n                        this.numberNode += '-';\n                    }\n                    else if (Char._0 <= c && c <= Char._9) {\n                        this.numberNode += String.fromCharCode(c);\n                        this.state = STATE.NUMBER_DIGIT;\n                    }\n                    else\n                        this._error('Bad value');\n                    continue;\n                case STATE.CLOSE_ARRAY:\n                    if (c === Char.comma) {\n                        this.stack.push(STATE.CLOSE_ARRAY);\n                        this._closeValue('onvalue');\n                        this.state = STATE.VALUE;\n                    }\n                    else if (c === Char.closeBracket) {\n                        this.emitNode('onclosearray');\n                        this.depth--;\n                        this.state = this.stack.pop() || STATE.VALUE;\n                    }\n                    else if (isWhitespace(c))\n                        continue;\n                    else\n                        this._error('Bad array');\n                    continue;\n                case STATE.STRING:\n                    if (this.textNode === undefined) {\n                        this.textNode = '';\n                    }\n                    // thanks thejh, this is an about 50% performance improvement.\n                    let starti = i - 1;\n                    let slashed = this.slashed;\n                    let unicodeI = this.unicodeI;\n                    // eslint-disable-next-line no-constant-condition, no-labels\n                    STRING_BIGLOOP: while (true) {\n                        // if (DEBUG) console.log(i, c, STATE[this.state], slashed);\n                        // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n                        while (unicodeI > 0) {\n                            this.unicodeS += String.fromCharCode(c);\n                            c = chunk.charCodeAt(i++);\n                            this.position++;\n                            if (unicodeI === 4) {\n                                // TODO this might be slow? well, probably not used too often anyway\n                                this.textNode += String.fromCharCode(parseInt(this.unicodeS, 16));\n                                unicodeI = 0;\n                                starti = i - 1;\n                            }\n                            else {\n                                unicodeI++;\n                            }\n                            // we can just break here: no stuff we skipped that still has to be sliced out or so\n                            // eslint-disable-next-line no-labels\n                            if (!c)\n                                break STRING_BIGLOOP;\n                        }\n                        if (c === Char.doubleQuote && !slashed) {\n                            this.state = this.stack.pop() || STATE.VALUE;\n                            this.textNode += chunk.substring(starti, i - 1);\n                            this.position += i - 1 - starti;\n                            break;\n                        }\n                        if (c === Char.backslash && !slashed) {\n                            slashed = true;\n                            this.textNode += chunk.substring(starti, i - 1);\n                            this.position += i - 1 - starti;\n                            c = chunk.charCodeAt(i++);\n                            this.position++;\n                            if (!c)\n                                break;\n                        }\n                        if (slashed) {\n                            slashed = false;\n                            if (c === Char.n) {\n                                this.textNode += '\\n';\n                            }\n                            else if (c === Char.r) {\n                                this.textNode += '\\r';\n                            }\n                            else if (c === Char.t) {\n                                this.textNode += '\\t';\n                            }\n                            else if (c === Char.f) {\n                                this.textNode += '\\f';\n                            }\n                            else if (c === Char.b) {\n                                this.textNode += '\\b';\n                            }\n                            else if (c === Char.u) {\n                                // \\uxxxx. meh!\n                                unicodeI = 1;\n                                this.unicodeS = '';\n                            }\n                            else {\n                                this.textNode += String.fromCharCode(c);\n                            }\n                            c = chunk.charCodeAt(i++);\n                            this.position++;\n                            starti = i - 1;\n                            if (!c)\n                                break;\n                            else\n                                continue;\n                        }\n                        stringTokenPattern.lastIndex = i;\n                        const reResult = stringTokenPattern.exec(chunk);\n                        if (reResult === null) {\n                            i = chunk.length + 1;\n                            this.textNode += chunk.substring(starti, i - 1);\n                            this.position += i - 1 - starti;\n                            break;\n                        }\n                        i = reResult.index + 1;\n                        c = chunk.charCodeAt(reResult.index);\n                        if (!c) {\n                            this.textNode += chunk.substring(starti, i - 1);\n                            this.position += i - 1 - starti;\n                            break;\n                        }\n                    }\n                    this.slashed = slashed;\n                    this.unicodeI = unicodeI;\n                    continue;\n                case STATE.TRUE:\n                    if (c === Char.r)\n                        this.state = STATE.TRUE2;\n                    else\n                        this._error(`Invalid true started with t${c}`);\n                    continue;\n                case STATE.TRUE2:\n                    if (c === Char.u)\n                        this.state = STATE.TRUE3;\n                    else\n                        this._error(`Invalid true started with tr${c}`);\n                    continue;\n                case STATE.TRUE3:\n                    if (c === Char.e) {\n                        this.emit('onvalue', true);\n                        this.state = this.stack.pop() || STATE.VALUE;\n                    }\n                    else\n                        this._error(`Invalid true started with tru${c}`);\n                    continue;\n                case STATE.FALSE:\n                    if (c === Char.a)\n                        this.state = STATE.FALSE2;\n                    else\n                        this._error(`Invalid false started with f${c}`);\n                    continue;\n                case STATE.FALSE2:\n                    if (c === Char.l)\n                        this.state = STATE.FALSE3;\n                    else\n                        this._error(`Invalid false started with fa${c}`);\n                    continue;\n                case STATE.FALSE3:\n                    if (c === Char.s)\n                        this.state = STATE.FALSE4;\n                    else\n                        this._error(`Invalid false started with fal${c}`);\n                    continue;\n                case STATE.FALSE4:\n                    if (c === Char.e) {\n                        this.emit('onvalue', false);\n                        this.state = this.stack.pop() || STATE.VALUE;\n                    }\n                    else\n                        this._error(`Invalid false started with fals${c}`);\n                    continue;\n                case STATE.NULL:\n                    if (c === Char.u)\n                        this.state = STATE.NULL2;\n                    else\n                        this._error(`Invalid null started with n${c}`);\n                    continue;\n                case STATE.NULL2:\n                    if (c === Char.l)\n                        this.state = STATE.NULL3;\n                    else\n                        this._error(`Invalid null started with nu${c}`);\n                    continue;\n                case STATE.NULL3:\n                    if (c === Char.l) {\n                        this.emit('onvalue', null);\n                        this.state = this.stack.pop() || STATE.VALUE;\n                    }\n                    else\n                        this._error(`Invalid null started with nul${c}`);\n                    continue;\n                case STATE.NUMBER_DECIMAL_POINT:\n                    if (c === Char.period) {\n                        this.numberNode += '.';\n                        this.state = STATE.NUMBER_DIGIT;\n                    }\n                    else\n                        this._error('Leading zero not followed by .');\n                    continue;\n                case STATE.NUMBER_DIGIT:\n                    if (Char._0 <= c && c <= Char._9)\n                        this.numberNode += String.fromCharCode(c);\n                    else if (c === Char.period) {\n                        if (this.numberNode.indexOf('.') !== -1)\n                            this._error('Invalid number has two dots');\n                        this.numberNode += '.';\n                    }\n                    else if (c === Char.e || c === Char.E) {\n                        if (this.numberNode.indexOf('e') !== -1 || this.numberNode.indexOf('E') !== -1)\n                            this._error('Invalid number has two exponential');\n                        this.numberNode += 'e';\n                    }\n                    else if (c === Char.plus || c === Char.minus) {\n                        // @ts-expect-error\n                        if (!(p === Char.e || p === Char.E))\n                            this._error('Invalid symbol in number');\n                        this.numberNode += String.fromCharCode(c);\n                    }\n                    else {\n                        this._closeNumber();\n                        i--; // go back one\n                        this.state = this.stack.pop() || STATE.VALUE;\n                    }\n                    continue;\n                default:\n                    this._error(`Unknown state: ${this.state}`);\n            }\n        }\n        if (this.position >= this.bufferCheckPosition) {\n            checkBufferLength(this);\n        }\n        this.emit('onchunkparsed');\n        return this;\n    }\n    _closeValue(event = 'onvalue') {\n        if (this.textNode !== undefined) {\n            this.emit(event, this.textNode);\n        }\n        this.textNode = undefined;\n    }\n    _closeNumber() {\n        if (this.numberNode)\n            this.emit('onvalue', parseFloat(this.numberNode));\n        this.numberNode = '';\n    }\n    _error(message = '') {\n        this._closeValue();\n        message += `\\nLine: ${this.line}\\nColumn: ${this.column}\\nChar: ${this.c}`;\n        const error = new Error(message);\n        this.error = error;\n        this.emit('onerror', error);\n    }\n}\nfunction isWhitespace(c) {\n    return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;\n}\nfunction checkBufferLength(parser) {\n    const maxAllowed = Math.max(MAX_BUFFER_LENGTH, 10);\n    let maxActual = 0;\n    for (const buffer of ['textNode', 'numberNode']) {\n        const len = parser[buffer] === undefined ? 0 : parser[buffer].length;\n        if (len > maxAllowed) {\n            switch (buffer) {\n                case 'text':\n                    // TODO - should this be closeValue?\n                    // closeText(parser);\n                    break;\n                default:\n                    parser._error(`Max buffer length exceeded: ${buffer}`);\n            }\n        }\n        maxActual = Math.max(maxActual, len);\n    }\n    parser.bufferCheckPosition = MAX_BUFFER_LENGTH - maxActual + parser.position;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * A parser for a minimal subset of the jsonpath standard\n * Full JSON path parsers for JS exist but are quite large (bundle size)\n *\n * Supports\n *\n *   `$.component.component.component`\n */\nexport default class JSONPath {\n    path;\n    constructor(path = null) {\n        this.path = ['$'];\n        if (path instanceof JSONPath) {\n            // @ts-ignore\n            this.path = [...path.path];\n            return;\n        }\n        if (Array.isArray(path)) {\n            this.path.push(...path);\n            return;\n        }\n        // Parse a string as a JSONPath\n        if (typeof path === 'string') {\n            this.path = path.split('.');\n            if (this.path[0] !== '$') {\n                throw new Error('JSONPaths must start with $');\n            }\n        }\n    }\n    clone() {\n        return new JSONPath(this);\n    }\n    toString() {\n        return this.path.join('.');\n    }\n    push(name) {\n        this.path.push(name);\n    }\n    pop() {\n        return this.path.pop();\n    }\n    set(name) {\n        this.path[this.path.length - 1] = name;\n    }\n    equals(other) {\n        if (!this || !other || this.path.length !== other.path.length) {\n            return false;\n        }\n        for (let i = 0; i < this.path.length; ++i) {\n            if (this.path[i] !== other.path[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sets the value pointed at by path\n     * TODO - handle root path\n     * @param object\n     * @param value\n     */\n    setFieldAtPath(object, value) {\n        const path = [...this.path];\n        path.shift();\n        const field = path.pop();\n        for (const component of path) {\n            object = object[component];\n        }\n        // @ts-ignore\n        object[field] = value;\n    }\n    /**\n     * Gets the value pointed at by path\n     * TODO - handle root path\n     * @param object\n     */\n    getFieldAtPath(object) {\n        const path = [...this.path];\n        path.shift();\n        const field = path.pop();\n        for (const component of path) {\n            object = object[component];\n        }\n        // @ts-ignore\n        return object[field];\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// @ts-nocheck\nimport ClarinetParser from \"../clarinet/clarinet.js\";\nimport JSONPath from \"../jsonpath/jsonpath.js\";\n// JSONParser builds a JSON object using the events emitted by the Clarinet parser\nexport default class JSONParser {\n    parser;\n    result = undefined;\n    previousStates = [];\n    currentState = Object.freeze({ container: [], key: null });\n    jsonpath = new JSONPath();\n    constructor(options) {\n        this.reset();\n        this.parser = new ClarinetParser({\n            onready: () => {\n                this.jsonpath = new JSONPath();\n                this.previousStates.length = 0;\n                this.currentState.container.length = 0;\n            },\n            onopenobject: (name) => {\n                this._openObject({});\n                if (typeof name !== 'undefined') {\n                    this.parser.emit('onkey', name);\n                }\n            },\n            onkey: (name) => {\n                this.jsonpath.set(name);\n                this.currentState.key = name;\n            },\n            oncloseobject: () => {\n                this._closeObject();\n            },\n            onopenarray: () => {\n                this._openArray();\n            },\n            onclosearray: () => {\n                this._closeArray();\n            },\n            onvalue: (value) => {\n                this._pushOrSet(value);\n            },\n            onerror: (error) => {\n                throw error;\n            },\n            onend: () => {\n                this.result = this.currentState.container.pop();\n            },\n            ...options\n        });\n    }\n    reset() {\n        this.result = undefined;\n        this.previousStates = [];\n        this.currentState = Object.freeze({ container: [], key: null });\n        this.jsonpath = new JSONPath();\n    }\n    write(chunk) {\n        this.parser.write(chunk);\n    }\n    close() {\n        this.parser.close();\n    }\n    // PRIVATE METHODS\n    _pushOrSet(value) {\n        const { container, key } = this.currentState;\n        if (key !== null) {\n            container[key] = value;\n            this.currentState.key = null;\n        }\n        else {\n            container.push(value);\n        }\n    }\n    _openArray(newContainer = []) {\n        this.jsonpath.push(null);\n        this._pushOrSet(newContainer);\n        this.previousStates.push(this.currentState);\n        this.currentState = { container: newContainer, isArray: true, key: null };\n    }\n    _closeArray() {\n        this.jsonpath.pop();\n        this.currentState = this.previousStates.pop();\n    }\n    _openObject(newContainer = {}) {\n        this.jsonpath.push(null);\n        this._pushOrSet(newContainer);\n        this.previousStates.push(this.currentState);\n        this.currentState = { container: newContainer, isArray: false, key: null };\n    }\n    _closeObject() {\n        this.jsonpath.pop();\n        this.currentState = this.previousStates.pop();\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { default as JSONParser } from \"./json-parser.js\";\nimport JSONPath from \"../jsonpath/jsonpath.js\";\n/**\n * The `StreamingJSONParser` looks for the first array in the JSON structure.\n * and emits an array of chunks\n */\nexport default class StreamingJSONParser extends JSONParser {\n    jsonPaths;\n    streamingJsonPath = null;\n    streamingArray = null;\n    topLevelObject = null;\n    constructor(options = {}) {\n        super({\n            onopenarray: () => {\n                if (!this.streamingArray) {\n                    if (this._matchJSONPath()) {\n                        // @ts-ignore\n                        this.streamingJsonPath = this.getJsonPath().clone();\n                        this.streamingArray = [];\n                        this._openArray(this.streamingArray);\n                        return;\n                    }\n                }\n                this._openArray();\n            },\n            // Redefine onopenarray to inject value for top-level object\n            onopenobject: (name) => {\n                if (!this.topLevelObject) {\n                    this.topLevelObject = {};\n                    this._openObject(this.topLevelObject);\n                }\n                else {\n                    this._openObject({});\n                }\n                if (typeof name !== 'undefined') {\n                    this.parser.emit('onkey', name);\n                }\n            }\n        });\n        const jsonpaths = options.jsonpaths || [];\n        this.jsonPaths = jsonpaths.map((jsonpath) => new JSONPath(jsonpath));\n    }\n    /**\n     * write REDEFINITION\n     * - super.write() chunk to parser\n     * - get the contents (so far) of \"topmost-level\" array as batch of rows\n     * - clear top-level array\n     * - return the batch of rows\\\n     */\n    write(chunk) {\n        super.write(chunk);\n        let array = [];\n        if (this.streamingArray) {\n            array = [...this.streamingArray];\n            this.streamingArray.length = 0;\n        }\n        return array;\n    }\n    /**\n     * Returns a partially formed result object\n     * Useful for returning the \"wrapper\" object when array is not top level\n     * e.g. GeoJSON\n     */\n    getPartialResult() {\n        return this.topLevelObject;\n    }\n    getStreamingJsonPath() {\n        return this.streamingJsonPath;\n    }\n    getStreamingJsonPathAsString() {\n        return this.streamingJsonPath && this.streamingJsonPath.toString();\n    }\n    getJsonPath() {\n        return this.jsonpath;\n    }\n    // PRIVATE METHODS\n    /**\n     * Checks is this.getJsonPath matches the jsonpaths provided in options\n     */\n    _matchJSONPath() {\n        const currentPath = this.getJsonPath();\n        // console.debug(`Testing JSONPath`, currentPath);\n        // Backwards compatibility, match any array\n        // TODO implement using wildcard once that is supported\n        if (this.jsonPaths.length === 0) {\n            return true;\n        }\n        for (const jsonPath of this.jsonPaths) {\n            if (jsonPath.equals(currentPath)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { TableBatchBuilder } from '@loaders.gl/schema';\nimport { assert, makeTextDecoderIterator } from '@loaders.gl/loader-utils';\nimport StreamingJSONParser from \"../json-parser/streaming-json-parser.js\";\nimport JSONPath from \"../jsonpath/jsonpath.js\";\n// TODO - support batch size 0 = no batching/single batch?\n// eslint-disable-next-line max-statements, complexity\nexport async function* parseJSONInBatches(binaryAsyncIterator, options) {\n    const asyncIterator = makeTextDecoderIterator(binaryAsyncIterator);\n    const { metadata } = options;\n    const { jsonpaths } = options.json || {};\n    let isFirstChunk = true;\n    // @ts-expect-error TODO fix Schema deduction\n    const schema = null;\n    const tableBatchBuilder = new TableBatchBuilder(schema, options);\n    const parser = new StreamingJSONParser({ jsonpaths });\n    for await (const chunk of asyncIterator) {\n        const rows = parser.write(chunk);\n        const jsonpath = rows.length > 0 && parser.getStreamingJsonPathAsString();\n        if (rows.length > 0 && isFirstChunk) {\n            if (metadata) {\n                const initialBatch = {\n                    // Common fields\n                    shape: options?.json?.shape || 'array-row-table',\n                    batchType: 'partial-result',\n                    data: [],\n                    length: 0,\n                    bytesUsed: 0,\n                    // JSON additions\n                    container: parser.getPartialResult(),\n                    jsonpath\n                };\n                yield initialBatch;\n            }\n            isFirstChunk = false;\n            // schema = deduceSchema(rows);\n        }\n        // Add the row\n        for (const row of rows) {\n            tableBatchBuilder.addRow(row);\n            // If a batch has been completed, emit it\n            const batch = tableBatchBuilder.getFullBatch({ jsonpath });\n            if (batch) {\n                yield batch;\n            }\n        }\n        tableBatchBuilder.chunkComplete(chunk);\n        const batch = tableBatchBuilder.getFullBatch({ jsonpath });\n        if (batch) {\n            yield batch;\n        }\n    }\n    // yield final batch\n    const jsonpath = parser.getStreamingJsonPathAsString();\n    const batch = tableBatchBuilder.getFinalBatch({ jsonpath });\n    if (batch) {\n        yield batch;\n    }\n    if (metadata) {\n        const finalBatch = {\n            shape: 'json',\n            batchType: 'final-result',\n            container: parser.getPartialResult(),\n            jsonpath: parser.getStreamingJsonPathAsString(),\n            /** Data Just to avoid crashing? */\n            data: [],\n            length: 0\n            // schema: null\n        };\n        yield finalBatch;\n    }\n}\nexport function rebuildJsonObject(batch, data) {\n    // Last batch will have this special type and will provide all the root object of the parsed file\n    assert(batch.batchType === 'final-result');\n    // The streamed JSON data is a top level array (jsonpath = '$'), just return the array of row objects\n    if (batch.jsonpath === '$') {\n        return data;\n    }\n    // (jsonpath !== '$') The streamed data is not a top level array, so stitch it back in to the top-level object\n    if (batch.jsonpath && batch.jsonpath.length > 1) {\n        const topLevelObject = batch.container;\n        const streamingPath = new JSONPath(batch.jsonpath);\n        streamingPath.setFieldAtPath(topLevelObject, data);\n        return topLevelObject;\n    }\n    // No jsonpath, in this case nothing was streamed.\n    return batch.container;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseJSONSync } from \"./lib/parsers/parse-json.js\";\nimport { parseJSONInBatches } from \"./lib/parsers/parse-json-in-batches.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.2\" !== 'undefined' ? \"4.3.2\" : 'latest';\nexport const JSONLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'JSON',\n    id: 'json',\n    module: 'json',\n    version: VERSION,\n    extensions: ['json', 'geojson'],\n    mimeTypes: ['application/json'],\n    category: 'table',\n    text: true,\n    options: {\n        json: {\n            shape: undefined,\n            table: false,\n            jsonpaths: []\n            // batchSize: 'auto'\n        }\n    },\n    parse,\n    parseTextSync,\n    parseInBatches\n};\nasync function parse(arrayBuffer, options) {\n    return parseTextSync(new TextDecoder().decode(arrayBuffer), options);\n}\nfunction parseTextSync(text, options) {\n    const jsonOptions = { ...options, json: { ...JSONLoader.options.json, ...options?.json } };\n    return parseJSONSync(text, jsonOptions);\n}\nfunction parseInBatches(asyncIterator, options) {\n    const jsonOptions = { ...options, json: { ...JSONLoader.options.json, ...options?.json } };\n    return parseJSONInBatches(asyncIterator, jsonOptions);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { makeTableFromData } from '@loaders.gl/schema';\nexport function parseNDJSONSync(ndjsonText) {\n    const lines = ndjsonText.trim().split('\\n');\n    const parsedLines = lines.map((line, counter) => {\n        try {\n            return JSON.parse(line);\n        }\n        catch (error) {\n            throw new Error(`NDJSONLoader: failed to parse JSON on line ${counter + 1}`);\n        }\n    });\n    return makeTableFromData(parsedLines);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { TableBatchBuilder } from '@loaders.gl/schema';\nimport { makeLineIterator, makeNumberedLineIterator, makeTextDecoderIterator } from '@loaders.gl/loader-utils';\nexport async function* parseNDJSONInBatches(binaryAsyncIterator, options) {\n    const textIterator = makeTextDecoderIterator(binaryAsyncIterator);\n    const lineIterator = makeLineIterator(textIterator);\n    const numberedLineIterator = makeNumberedLineIterator(lineIterator);\n    const schema = null;\n    const shape = 'row-table';\n    // @ts-ignore\n    const tableBatchBuilder = new TableBatchBuilder(schema, {\n        ...options,\n        shape\n    });\n    for await (const { counter, line } of numberedLineIterator) {\n        try {\n            const row = JSON.parse(line);\n            tableBatchBuilder.addRow(row);\n            tableBatchBuilder.chunkComplete(line);\n            const batch = tableBatchBuilder.getFullBatch();\n            if (batch) {\n                yield batch;\n            }\n        }\n        catch (error) {\n            throw new Error(`NDJSONLoader: failed to parse JSON on line ${counter}`);\n        }\n    }\n    const batch = tableBatchBuilder.getFinalBatch();\n    if (batch) {\n        yield batch;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { parseNDJSONSync } from \"./lib/parsers/parse-ndjson.js\";\nimport { parseNDJSONInBatches } from \"./lib/parsers/parse-ndjson-in-batches.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.2\" !== 'undefined' ? \"4.3.2\" : 'latest';\nexport const NDJSONLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'NDJSON',\n    id: 'ndjson',\n    module: 'json',\n    version: VERSION,\n    extensions: ['ndjson', 'jsonl'],\n    mimeTypes: [\n        'application/x-ndjson',\n        'application/jsonlines', // https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-inference.html#cm-batch\n        'application/json-seq'\n    ],\n    category: 'table',\n    text: true,\n    parse: async (arrayBuffer) => parseNDJSONSync(new TextDecoder().decode(arrayBuffer)),\n    parseTextSync: parseNDJSONSync,\n    parseInBatches: parseNDJSONInBatches,\n    options: {}\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright 2022 Foursquare Labs, Inc.\nimport { makeRowIterator } from '@loaders.gl/schema';\n/**\n * Encode a table as a JSON string\n */\nexport function encodeTableAsJSON(table, options) {\n    const shape = options?.json?.shape || 'object-row-table';\n    const strings = [];\n    const rowIterator = makeRowIterator(table, shape);\n    for (const row of rowIterator) {\n        // Round elements etc\n        // processRow(wrappedRow, table.schema);\n        // const wrappedRow = options.wrapper ? options.wrapper(row) : row;\n        strings.push(JSON.stringify(row));\n    }\n    return `[${strings.join(',')}]`;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright 2022 Foursquare Labs, Inc.\nimport { encodeTableAsJSON } from \"./lib/encoders/json-encoder.js\";\nexport const JSONWriter = {\n    id: 'json',\n    version: 'latest',\n    module: 'json',\n    name: 'JSON',\n    extensions: ['json'],\n    mimeTypes: ['application/json'],\n    options: {},\n    text: true,\n    encode: async (table, options) => new TextEncoder().encode(encodeTableAsJSON(table, options)).buffer,\n    encodeTextSync: (table, options) => encodeTableAsJSON(table, options)\n};\n", "/* eslint-disable indent */\nimport { earcut } from '@math.gl/polygon';\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(features, geometryInfo, options) {\n    const propArrayTypes = extractNumericPropTypes(features);\n    const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);\n    return fillArrays(features, {\n        propArrayTypes,\n        ...geometryInfo\n    }, {\n        numericPropKeys: (options && options.numericPropKeys) || numericPropKeys,\n        PositionDataType: options ? options.PositionDataType : Float32Array,\n        triangulate: options ? options.triangulate : true\n    });\n}\nexport const TEST_EXPORTS = {\n    extractNumericPropTypes\n};\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features) {\n    const propArrayTypes = {};\n    for (const feature of features) {\n        if (feature.properties) {\n            for (const key in feature.properties) {\n                // If property has not been seen before, or if property has been numeric\n                // in all previous features, check if numeric in this feature\n                // If not numeric, Array is stored to prevent rechecking in the future\n                // Additionally, detects if 64 bit precision is required\n                const val = feature.properties[key];\n                propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n            }\n        }\n    }\n    return propArrayTypes;\n}\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity, max-statements\nfunction fillArrays(features, geometryInfo, options) {\n    const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;\n    const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;\n    const hasGlobalId = features[0] && 'id' in features[0];\n    const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n    const points = {\n        type: 'Point',\n        positions: new PositionDataType(pointPositionsCount * coordLength),\n        globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n        featureIds: pointFeaturesCount > 65535\n            ? new Uint32Array(pointPositionsCount)\n            : new Uint16Array(pointPositionsCount),\n        numericProps: {},\n        properties: [],\n        fields: []\n    };\n    const lines = {\n        type: 'LineString',\n        pathIndices: linePositionsCount > 65535\n            ? new Uint32Array(linePathsCount + 1)\n            : new Uint16Array(linePathsCount + 1),\n        positions: new PositionDataType(linePositionsCount * coordLength),\n        globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n        featureIds: lineFeaturesCount > 65535\n            ? new Uint32Array(linePositionsCount)\n            : new Uint16Array(linePositionsCount),\n        numericProps: {},\n        properties: [],\n        fields: []\n    };\n    const polygons = {\n        type: 'Polygon',\n        polygonIndices: polygonPositionsCount > 65535\n            ? new Uint32Array(polygonObjectsCount + 1)\n            : new Uint16Array(polygonObjectsCount + 1),\n        primitivePolygonIndices: polygonPositionsCount > 65535\n            ? new Uint32Array(polygonRingsCount + 1)\n            : new Uint16Array(polygonRingsCount + 1),\n        positions: new PositionDataType(polygonPositionsCount * coordLength),\n        globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n        featureIds: polygonFeaturesCount > 65535\n            ? new Uint32Array(polygonPositionsCount)\n            : new Uint16Array(polygonPositionsCount),\n        numericProps: {},\n        properties: [],\n        fields: []\n    };\n    if (triangulate) {\n        polygons.triangles = [];\n    }\n    // Instantiate numeric properties arrays; one value per vertex\n    for (const object of [points, lines, polygons]) {\n        for (const propName of numericPropKeys) {\n            // If property has been numeric in all previous features in which the property existed, check\n            // if numeric in this feature\n            const T = propArrayTypes[propName];\n            object.numericProps[propName] = new T(object.positions.length / coordLength);\n        }\n    }\n    // Set last element of path/polygon indices as positions length\n    lines.pathIndices[linePathsCount] = linePositionsCount;\n    polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n    polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n    const indexMap = {\n        pointPosition: 0,\n        pointFeature: 0,\n        linePosition: 0,\n        linePath: 0,\n        lineFeature: 0,\n        polygonPosition: 0,\n        polygonObject: 0,\n        polygonRing: 0,\n        polygonFeature: 0,\n        feature: 0\n    };\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        const properties = feature.properties || {};\n        switch (geometry.type) {\n            case 'Point':\n                handlePoint(geometry, points, indexMap, coordLength, properties);\n                points.properties.push(keepStringProperties(properties, numericPropKeys));\n                if (hasGlobalId) {\n                    points.fields.push({ id: feature.id });\n                }\n                indexMap.pointFeature++;\n                break;\n            case 'LineString':\n                handleLineString(geometry, lines, indexMap, coordLength, properties);\n                lines.properties.push(keepStringProperties(properties, numericPropKeys));\n                if (hasGlobalId) {\n                    lines.fields.push({ id: feature.id });\n                }\n                indexMap.lineFeature++;\n                break;\n            case 'Polygon':\n                handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n                polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n                if (hasGlobalId) {\n                    polygons.fields.push({ id: feature.id });\n                }\n                indexMap.polygonFeature++;\n                break;\n            default:\n                throw new Error('Invalid geometry type');\n        }\n        indexMap.feature++;\n    }\n    // Wrap each array in an accessor object with value and size keys\n    return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n    points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n    const nPositions = geometry.data.length / coordLength;\n    fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n    points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n    points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n    indexMap.pointPosition += nPositions;\n}\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n    lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n    const nPositions = geometry.data.length / coordLength;\n    fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n    lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n    lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n    for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n        // Extract range of data we are working with, defined by start\n        // and end indices (these index into the geometry.data array)\n        const start = geometry.indices[i];\n        const end = i === il - 1\n            ? geometry.data.length // last line, so read to end of data\n            : geometry.indices[i + 1]; // start index for next line\n        lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n        indexMap.linePosition += (end - start) / coordLength;\n    }\n}\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n    polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n    const nPositions = geometry.data.length / coordLength;\n    fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n    polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n    polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n    // Unlike Point & LineString geometry.indices is a 2D array\n    for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n        const startPosition = indexMap.polygonPosition;\n        polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n        const areas = geometry.areas[l];\n        const indices = geometry.indices[l];\n        const nextIndices = geometry.indices[l + 1];\n        for (let i = 0, il = indices.length; i < il; ++i) {\n            const start = indices[i];\n            const end = i === il - 1\n                ? // last line, so either read to:\n                    nextIndices === undefined\n                        ? geometry.data.length // end of data (no next indices)\n                        : nextIndices[0] // start of first line in nextIndices\n                : indices[i + 1]; // start index for next line\n            polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n            indexMap.polygonPosition += (end - start) / coordLength;\n        }\n        const endPosition = indexMap.polygonPosition;\n        triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });\n    }\n}\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {\n    if (!polygons.triangles) {\n        return;\n    }\n    const start = startPosition * coordLength;\n    const end = endPosition * coordLength;\n    // Extract positions and holes for just this polygon\n    const polygonPositions = polygons.positions.subarray(start, end);\n    // Holes are referenced relative to outer polygon\n    const offset = indices[0];\n    const holes = indices.slice(1).map((n) => (n - offset) / coordLength);\n    // Compute triangulation\n    const triangles = earcut(polygonPositions, holes, coordLength, areas);\n    // Indices returned by triangulation are relative to start\n    // of polygon, so we need to offset\n    for (let t = 0, tl = triangles.length; t < tl; ++t) {\n        polygons.triangles.push(startPosition + triangles[t]);\n    }\n}\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(obj, size) {\n    const returnObj = {};\n    for (const key in obj) {\n        returnObj[key] = { value: obj[key], size };\n    }\n    return returnObj;\n}\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n    const binaryFeatures = {\n        shape: 'binary-feature-collection',\n        points: {\n            ...points,\n            positions: { value: points.positions, size: coordLength },\n            globalFeatureIds: { value: points.globalFeatureIds, size: 1 },\n            featureIds: { value: points.featureIds, size: 1 },\n            numericProps: wrapProps(points.numericProps, 1)\n        },\n        lines: {\n            ...lines,\n            positions: { value: lines.positions, size: coordLength },\n            pathIndices: { value: lines.pathIndices, size: 1 },\n            globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },\n            featureIds: { value: lines.featureIds, size: 1 },\n            numericProps: wrapProps(lines.numericProps, 1)\n        },\n        polygons: {\n            ...polygons,\n            positions: { value: polygons.positions, size: coordLength },\n            polygonIndices: { value: polygons.polygonIndices, size: 1 },\n            primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },\n            globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },\n            featureIds: { value: polygons.featureIds, size: 1 },\n            numericProps: wrapProps(polygons.numericProps, 1)\n        } // triangles not expected\n    };\n    if (binaryFeatures.polygons && polygons.triangles) {\n        binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };\n    }\n    return binaryFeatures;\n}\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(object, properties, index, length) {\n    for (const numericPropName in object.numericProps) {\n        if (numericPropName in properties) {\n            const value = properties[numericPropName];\n            object.numericProps[numericPropName].fill(value, index, index + length);\n        }\n    }\n}\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(properties, numericKeys) {\n    const props = {};\n    for (const key in properties) {\n        if (!numericKeys.includes(key)) {\n            props[key] = properties[key];\n        }\n    }\n    return props;\n}\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x, constructor) {\n    if (constructor === Array || !Number.isFinite(x)) {\n        return Array;\n    }\n    // If this or previous value required 64bits use Float64Array\n    return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n", "/**\n *  Initial scan over GeoJSON features\n *  Counts number of coordinates of each geometry type and\n *  keeps track of the max coordinate dimensions\n */\n// eslint-disable-next-line complexity, max-statements\nexport function extractGeometryInfo(features) {\n    // Counts the number of _positions_, so [x, y, z] counts as one\n    let pointPositionsCount = 0;\n    let pointFeaturesCount = 0;\n    let linePositionsCount = 0;\n    let linePathsCount = 0;\n    let lineFeaturesCount = 0;\n    let polygonPositionsCount = 0;\n    let polygonObjectsCount = 0;\n    let polygonRingsCount = 0;\n    let polygonFeaturesCount = 0;\n    const coordLengths = new Set();\n    for (const feature of features) {\n        const geometry = feature.geometry;\n        switch (geometry.type) {\n            case 'Point':\n                pointFeaturesCount++;\n                pointPositionsCount++;\n                coordLengths.add(geometry.coordinates.length);\n                break;\n            case 'MultiPoint':\n                pointFeaturesCount++;\n                pointPositionsCount += geometry.coordinates.length;\n                for (const point of geometry.coordinates) {\n                    coordLengths.add(point.length);\n                }\n                break;\n            case 'LineString':\n                lineFeaturesCount++;\n                linePositionsCount += geometry.coordinates.length;\n                linePathsCount++;\n                for (const coord of geometry.coordinates) {\n                    coordLengths.add(coord.length);\n                }\n                break;\n            case 'MultiLineString':\n                lineFeaturesCount++;\n                for (const line of geometry.coordinates) {\n                    linePositionsCount += line.length;\n                    linePathsCount++;\n                    // eslint-disable-next-line max-depth\n                    for (const coord of line) {\n                        coordLengths.add(coord.length);\n                    }\n                }\n                break;\n            case 'Polygon':\n                polygonFeaturesCount++;\n                polygonObjectsCount++;\n                polygonRingsCount += geometry.coordinates.length;\n                const flattened = geometry.coordinates.flat();\n                polygonPositionsCount += flattened.length;\n                for (const coord of flattened) {\n                    coordLengths.add(coord.length);\n                }\n                break;\n            case 'MultiPolygon':\n                polygonFeaturesCount++;\n                for (const polygon of geometry.coordinates) {\n                    polygonObjectsCount++;\n                    polygonRingsCount += polygon.length;\n                    const flattened = polygon.flat();\n                    polygonPositionsCount += flattened.length;\n                    // eslint-disable-next-line max-depth\n                    for (const coord of flattened) {\n                        coordLengths.add(coord.length);\n                    }\n                }\n                break;\n            default:\n                throw new Error(`Unsupported geometry type: ${geometry.type}`);\n        }\n    }\n    return {\n        coordLength: coordLengths.size > 0 ? Math.max(...coordLengths) : 2,\n        pointPositionsCount,\n        pointFeaturesCount,\n        linePositionsCount,\n        linePathsCount,\n        lineFeaturesCount,\n        polygonPositionsCount,\n        polygonObjectsCount,\n        polygonRingsCount,\n        polygonFeaturesCount\n    };\n}\n", "import { getPolygonSignedArea } from '@math.gl/polygon';\n/**\n * Convert GeoJSON features to Flat GeoJSON features\n *\n * @param features\n * @param options\n * @returns an Array of Flat GeoJSON features\n */\nexport function geojsonToFlatGeojson(features, options = { coordLength: 2, fixRingWinding: true }) {\n    return features.map((feature) => flattenFeature(feature, options));\n}\n/**\n * Helper function to copy Point values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenPoint(coordinates, data, indices, options) {\n    indices.push(data.length);\n    data.push(...coordinates);\n    // Pad up to coordLength\n    for (let i = coordinates.length; i < options.coordLength; i++) {\n        data.push(0);\n    }\n}\n/**\n * Helper function to copy LineString values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenLineString(coordinates, data, indices, options) {\n    indices.push(data.length);\n    for (const c of coordinates) {\n        data.push(...c);\n        // Pad up to coordLength\n        for (let i = c.length; i < options.coordLength; i++) {\n            data.push(0);\n        }\n    }\n}\n/**\n * Helper function to copy Polygon values from `coordinates` into `data` & `indices` & `areas`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param areas\n * @param options\n */\nfunction flattenPolygon(coordinates, data, indices, areas, options) {\n    let count = 0;\n    const ringAreas = [];\n    const polygons = [];\n    for (const lineString of coordinates) {\n        const lineString2d = lineString.map((p) => p.slice(0, 2));\n        let area = getPolygonSignedArea(lineString2d.flat());\n        const ccw = area < 0;\n        // Exterior ring must be CCW and interior rings CW\n        if (options.fixRingWinding && ((count === 0 && !ccw) || (count > 0 && ccw))) {\n            lineString.reverse();\n            area = -area;\n        }\n        ringAreas.push(area);\n        flattenLineString(lineString, data, polygons, options);\n        count++;\n    }\n    if (count > 0) {\n        areas.push(ringAreas);\n        indices.push(polygons);\n    }\n}\n/**\n * Flatten single GeoJSON feature into Flat GeoJSON\n *\n * @param feature\n * @param options\n * @returns A Flat GeoJSON feature\n */\nfunction flattenFeature(feature, options) {\n    const { geometry } = feature;\n    if (geometry.type === 'GeometryCollection') {\n        throw new Error('GeometryCollection type not supported');\n    }\n    const data = [];\n    const indices = [];\n    let areas;\n    let type;\n    switch (geometry.type) {\n        case 'Point':\n            type = 'Point';\n            flattenPoint(geometry.coordinates, data, indices, options);\n            break;\n        case 'MultiPoint':\n            type = 'Point';\n            geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));\n            break;\n        case 'LineString':\n            type = 'LineString';\n            flattenLineString(geometry.coordinates, data, indices, options);\n            break;\n        case 'MultiLineString':\n            type = 'LineString';\n            geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));\n            break;\n        case 'Polygon':\n            type = 'Polygon';\n            areas = [];\n            flattenPolygon(geometry.coordinates, data, indices, areas, options);\n            break;\n        case 'MultiPolygon':\n            type = 'Polygon';\n            areas = [];\n            geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));\n            break;\n        default:\n            throw new Error(`Unknown type: ${type}`);\n    }\n    return { ...feature, geometry: { type, indices, data, areas } };\n}\n", "import { extractGeometryInfo } from \"./extract-geometry-info.js\";\nimport { geojsonToFlatGeojson } from \"./geojson-to-flat-geojson.js\";\nimport { flatGeojsonToBinary } from \"./flat-geojson-to-binary.js\";\n/**\n * Convert GeoJSON features to flat binary arrays\n *\n * @param features\n * @param options\n * @returns features in binary format, grouped by geometry type\n */\nexport function geojsonToBinary(features, options = { fixRingWinding: true, triangulate: true }) {\n    const geometryInfo = extractGeometryInfo(features);\n    const coordLength = geometryInfo.coordLength;\n    const { fixRingWinding } = options;\n    const flatFeatures = geojsonToFlatGeojson(features, { coordLength, fixRingWinding });\n    return flatGeojsonToBinary(flatFeatures, geometryInfo, {\n        numericPropKeys: options.numericPropKeys,\n        PositionDataType: options.PositionDataType || Float32Array,\n        triangulate: options.triangulate\n    });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { geojsonToBinary } from '@loaders.gl/gis';\n// import {parseJSONSync} from './lib/parsers/parse-json';\nimport { parseJSONInBatches } from \"./lib/parsers/parse-json-in-batches.js\";\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof \"4.3.2\" !== 'undefined' ? \"4.3.2\" : 'latest';\n/**\n * GeoJSON loader\n */\nexport const GeoJSONWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'GeoJSON',\n    id: 'geojson',\n    module: 'geojson',\n    version: VERSION,\n    worker: true,\n    extensions: ['geojson'],\n    mimeTypes: ['application/geo+json'],\n    category: 'geometry',\n    text: true,\n    options: {\n        geojson: {\n            shape: 'geojson-table'\n        },\n        json: {\n            shape: 'object-row-table',\n            jsonpaths: ['$', '$.features']\n        },\n        gis: {\n            format: 'geojson'\n        }\n    }\n};\nexport const GeoJSONLoader = {\n    ...GeoJSONWorkerLoader,\n    // @ts-expect-error\n    parse,\n    // @ts-expect-error\n    parseTextSync,\n    parseInBatches\n};\nasync function parse(arrayBuffer, options) {\n    return parseTextSync(new TextDecoder().decode(arrayBuffer), options);\n}\nfunction parseTextSync(text, options) {\n    // Apps can call the parse method directly, we so apply default options here\n    options = { ...GeoJSONLoader.options, ...options };\n    options.geojson = { ...GeoJSONLoader.options.geojson, ...options.geojson };\n    options.gis = options.gis || {};\n    let geojson;\n    try {\n        geojson = JSON.parse(text);\n    }\n    catch {\n        geojson = {};\n    }\n    const table = {\n        shape: 'geojson-table',\n        // TODO - deduce schema from geojson\n        // TODO check that parsed data is of type FeatureCollection\n        type: 'FeatureCollection',\n        features: geojson?.features || []\n    };\n    switch (options.gis.format) {\n        case 'binary':\n            return geojsonToBinary(table.features);\n        default:\n            return table;\n    }\n}\nfunction parseInBatches(asyncIterator, options) {\n    // Apps can call the parse method directly, we so apply default options here\n    options = { ...GeoJSONLoader.options, ...options };\n    options.json = { ...GeoJSONLoader.options.geojson, ...options.geojson };\n    const geojsonIterator = parseJSONInBatches(asyncIterator, options);\n    switch (options.gis.format) {\n        case 'binary':\n            return makeBinaryGeometryIterator(geojsonIterator);\n        default:\n            return geojsonIterator;\n    }\n}\nasync function* makeBinaryGeometryIterator(geojsonIterator) {\n    for await (const batch of geojsonIterator) {\n        batch.data = geojsonToBinary(batch.data);\n        yield batch;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright 2022 Foursquare Labs, Inc.\nimport { getTableLength, getTableNumCols, getTableRowAsArray } from '@loaders.gl/schema';\n/**\n * Attempts to identify which column contains geometry\n * Currently just returns name (key) of first object-valued column\n * @todo look for hints in schema metadata\n * @todo look for WKB\n */\nexport function detectGeometryColumnIndex(table) {\n    // TODO - look for hints in schema metadata\n    // look for a column named geometry\n    const geometryIndex = table.schema?.fields.findIndex((field) => field.name === 'geometry') ?? -1;\n    if (geometryIndex > -1) {\n        return geometryIndex;\n    }\n    // look at the data\n    // TODO - this drags in the indices\n    if (getTableLength(table) > 0) {\n        const row = getTableRowAsArray(table, 0);\n        for (let columnIndex = 0; columnIndex < getTableNumCols(table); columnIndex++) {\n            const value = row?.[columnIndex];\n            if (value && typeof value === 'object') {\n                return columnIndex;\n            }\n        }\n    }\n    throw new Error('Failed to detect geometry column');\n}\n/**\n * Return a row as a property (key/value) object, excluding selected columns\n */\nexport function getRowPropertyObject(table, row, excludeColumnIndices = []) {\n    const properties = {};\n    for (let columnIndex = 0; columnIndex < getTableNumCols(table); ++columnIndex) {\n        const columnName = table.schema?.fields[columnIndex].name;\n        if (columnName && !excludeColumnIndices.includes(columnIndex)) {\n            properties[columnName] = row[columnName];\n        }\n    }\n    return properties;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright 2022 Foursquare Labs, Inc.\nimport { getTableRowAsObject } from '@loaders.gl/schema';\nimport { getRowPropertyObject } from \"./encode-utils.js\";\n// Helpers\n/**\n * Encode a row. Currently this ignores properties in the geometry column.\n */\nexport function encodeTableRow(table, rowIndex, geometryColumnIndex, utf8Encoder) {\n    const row = getTableRowAsObject(table, rowIndex);\n    if (!row)\n        return;\n    const featureWithProperties = getFeatureFromRow(table, row, geometryColumnIndex);\n    const featureString = JSON.stringify(featureWithProperties);\n    utf8Encoder.push(featureString);\n}\n/**\n * Encode a row as a Feature. Currently this ignores properties objects in the geometry column.\n */\nfunction getFeatureFromRow(table, row, geometryColumnIndex) {\n    // Extract non-feature/geometry properties\n    const properties = getRowPropertyObject(table, row, [geometryColumnIndex]);\n    // Extract geometry feature\n    const columnName = table.schema?.fields[geometryColumnIndex].name;\n    let featureOrGeometry = columnName && row[columnName];\n    // GeoJSON support null geometries\n    if (!featureOrGeometry) {\n        // @ts-ignore Feature type does not support null geometries\n        return { type: 'Feature', geometry: null, properties };\n    }\n    // Support string geometries?\n    // TODO: This assumes GeoJSON strings, which may not be the correct format\n    // (could be WKT, encoded WKB...)\n    if (typeof featureOrGeometry === 'string') {\n        try {\n            featureOrGeometry = JSON.parse(featureOrGeometry);\n        }\n        catch (err) {\n            throw new Error('Invalid string geometry');\n        }\n    }\n    if (typeof featureOrGeometry !== 'object' || typeof featureOrGeometry?.type !== 'string') {\n        throw new Error('invalid geometry column value');\n    }\n    if (featureOrGeometry?.type === 'Feature') {\n        // @ts-ignore Feature type does not support null geometries\n        return { ...featureOrGeometry, properties };\n    }\n    // @ts-ignore Feature type does not support null geometries\n    return { type: 'Feature', geometry: featureOrGeometry, properties };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n/* global TextEncoder */\nexport class Utf8ArrayBufferEncoder {\n    chunkSize;\n    strings = [];\n    totalLength = 0;\n    textEncoder = new TextEncoder();\n    constructor(chunkSize) {\n        this.chunkSize = chunkSize;\n    }\n    push(...strings) {\n        for (const string of strings) {\n            this.strings.push(string);\n            this.totalLength += string.length;\n        }\n    }\n    isFull() {\n        return this.totalLength >= this.chunkSize;\n    }\n    getArrayBufferBatch() {\n        return this.textEncoder.encode(this.getStringBatch()).buffer;\n    }\n    getStringBatch() {\n        const stringChunk = this.strings.join('');\n        this.strings = [];\n        this.totalLength = 0;\n        return stringChunk;\n    }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright 2022 Foursquare Labs, Inc.\nimport { getTableLength } from '@loaders.gl/schema';\nimport { detectGeometryColumnIndex } from \"../encoder-utils/encode-utils.js\";\nimport { encodeTableRow } from \"../encoder-utils/encode-table-row.js\";\nimport { Utf8ArrayBufferEncoder } from \"../encoder-utils/utf8-encoder.js\";\n/**\n * Encode a table as GeoJSON\n */\n// eslint-disable-next-line max-statements\nexport async function* encodeTableAsGeojsonInBatches(batchIterator, // | Iterable<TableBatch>,\ninputOpts = {}) {\n    // @ts-expect-error\n    const options = { geojson: {}, chunkSize: 10000, ...inputOpts };\n    const utf8Encoder = new Utf8ArrayBufferEncoder(options.chunkSize);\n    if (!options.geojson.featureArray) {\n        utf8Encoder.push('{\\n', '\"type\": \"FeatureCollection\",\\n', '\"features\":\\n');\n    }\n    utf8Encoder.push('['); // Note no newline\n    let geometryColumn = options.geojson.geometryColumn;\n    let isFirstLine = true;\n    let start = 0;\n    for await (const tableBatch of batchIterator) {\n        const end = start + getTableLength(tableBatch);\n        // Deduce geometry column if not already done\n        if (!geometryColumn) {\n            geometryColumn = geometryColumn || detectGeometryColumnIndex(tableBatch);\n        }\n        for (let rowIndex = start; rowIndex < end; ++rowIndex) {\n            // Add a comma except on final feature\n            if (!isFirstLine) {\n                utf8Encoder.push(',');\n            }\n            utf8Encoder.push('\\n');\n            isFirstLine = false;\n            encodeTableRow(tableBatch, rowIndex, geometryColumn, utf8Encoder);\n            // eslint-disable-next-line max-depth\n            if (utf8Encoder.isFull()) {\n                yield utf8Encoder.getArrayBufferBatch();\n            }\n            start = end;\n        }\n        const arrayBufferBatch = utf8Encoder.getArrayBufferBatch();\n        if (arrayBufferBatch.byteLength > 0) {\n            yield arrayBufferBatch;\n        }\n    }\n    utf8Encoder.push('\\n');\n    // Add completing rows and emit final batch\n    utf8Encoder.push(']\\n');\n    if (!options.geojson.featureArray) {\n        utf8Encoder.push('}');\n    }\n    // Note: Since we pushed a few final lines, the last batch will always exist, no need to check first\n    yield utf8Encoder.getArrayBufferBatch();\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Copyright Foursquare, Inc 20222\nimport { concatenateArrayBuffersAsync } from '@loaders.gl/loader-utils';\nimport { encodeTableAsGeojsonInBatches } from \"./lib/encoders/geojson-encoder.js\";\nexport const GeoJSONWriter = {\n    id: 'geojson',\n    version: 'latest',\n    module: 'geojson',\n    name: 'GeoJSON',\n    extensions: ['geojson'],\n    mimeTypes: ['application/geo+json'],\n    text: true,\n    options: {\n        geojson: {\n            featureArray: false,\n            geometryColumn: null\n        }\n    },\n    async encode(table, options) {\n        const tableIterator = [table];\n        const batches = encodeTableAsGeojsonInBatches(tableIterator, options);\n        return await concatenateArrayBuffersAsync(batches);\n    },\n    encodeInBatches: (tableIterator, options) => encodeTableAsGeojsonInBatches(tableIterator, options)\n};\n"],
  "mappings": "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",
  "names": ["STATE", "jsonpath", "batch", "batch", "VERSION", "flattened", "VERSION", "parse", "parseTextSync", "parseInBatches"]
}
