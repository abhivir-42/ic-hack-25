var bboxClip = require('@turf/bbox-clip');
var bboxPolygon = require('@turf/bbox-polygon');
var union = require('@turf/union');
var invariant = require('@turf/invariant');
var helpers = require('@turf/helpers');

/**
 * @internal
 * @internalRemarks Source: @carto/react-core, @carto/constants, @deck.gl/carto
 */
let client = 'deck-gl-carto';
/**
 * Returns current client ID, used to categorize API requests. For internal use only.
 *
 * @internal
 * @internalRemarks Source: @carto/react-core
 */
function getClient() {
  return client;
}
/**
 * Sets current client ID, used to categorize API requests. For internal use only.
 *
 * @internal
 * @internalRemarks Source: @carto/react-core
 */
function setClient(c) {
  client = c;
}

/**
 * Defines a comparator used when matching a column's values against given filter values.
 *
 * Example:
 *
 * ```javascript
 * import { FilterType } from '@carto/api-client';
 * const filters = {
 *   column_name: { [FilterType.IN]: { values: ['a', 'b', 'c'] } }
 * };
 * ```
 *
 * @internalRemarks Source: @carto/react-api, @deck.gl/carto
 */
exports.FilterType = void 0;
(function (FilterType) {
  FilterType["IN"] = "in";
  /** [a, b] both are included. */
  FilterType["BETWEEN"] = "between";
  /** [a, b) a is included, b is not. */
  FilterType["CLOSED_OPEN"] = "closed_open";
  FilterType["TIME"] = "time";
  FilterType["STRING_SEARCH"] = "stringSearch";
})(exports.FilterType || (exports.FilterType = {}));
/** @internalRemarks Source: @carto/constants */
exports.ApiVersion = void 0;
(function (ApiVersion) {
  ApiVersion["V1"] = "v1";
  ApiVersion["V2"] = "v2";
  ApiVersion["V3"] = "v3";
})(exports.ApiVersion || (exports.ApiVersion = {}));
/** @internalRemarks Source: @carto/constants, @deck.gl/carto */
const DEFAULT_API_BASE_URL = 'https://gcp-us-east1.api.carto.com';

const FILTER_TYPES = new Set(Object.values(exports.FilterType));
const isFilterType = type => FILTER_TYPES.has(type);
/**
 * @privateRemarks Source: @carto/react-widgets
 * @internal
 */
function getApplicableFilters(owner, filters) {
  if (!filters) return {};
  const applicableFilters = {};
  for (const column in filters) {
    for (const type in filters[column]) {
      if (!isFilterType(type)) continue;
      const filter = filters[column][type];
      const isApplicable = !owner || !filter?.owner || filter?.owner !== owner;
      if (filter && isApplicable) {
        applicableFilters[column] ||= {};
        applicableFilters[column][type] = filter;
      }
    }
  }
  return applicableFilters;
}
/**
 * Due to each data warehouse having its own behavior with columns,
 * we need to normalize them and transform every key to lowercase.
 *
 * @internalRemarks Source: @carto/react-widgets
 * @internal
 */
function normalizeObjectKeys(el) {
  if (Array.isArray(el)) {
    return el.map(value => normalizeObjectKeys(value));
  } else if (typeof el !== 'object') {
    return el;
  }
  return Object.entries(el).reduce((acc, _ref) => {
    let [key, value] = _ref;
    acc[key.toLowerCase()] = typeof value === 'object' && value ? normalizeObjectKeys(value) : value;
    return acc;
  }, {});
}
/** @internalRemarks Source: @carto/react-core */
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
/**
 * @internalRemarks Source: @carto/react-core
 * @internal
 */
class InvalidColumnError extends Error {
  constructor(message) {
    super(`${InvalidColumnError.NAME}: ${message}`);
    this.name = InvalidColumnError.NAME;
  }
  static is(error) {
    return error instanceof InvalidColumnError || error.message?.includes(InvalidColumnError.NAME);
  }
}
InvalidColumnError.NAME = 'InvalidColumnError';
function isEmptyObject(object) {
  for (const _ in object) {
    return false;
  }
  return true;
}
/** @internal */
const isObject = x => x !== null && typeof x === 'object';
/** @internal */
const isPureObject = x => isObject(x) && x.constructor === {}.constructor;

/**
 * Adds a {@link Filter} to the filter set. Any previous filters with the same
 * `column` and `type` will be replaced.
 */
function addFilter(filters, _ref) {
  let {
    column,
    type,
    values,
    owner
  } = _ref;
  if (!filters[column]) {
    filters[column] = {};
  }
  const filter = {
    values,
    owner
  };
  filters[column][type] = filter;
  return filters;
}
/**
 * Removes one or more {@link Filter filters} from the filter set. If only
 * `column` is specified, then all filters on that column are removed. If both
 * `column` and `owner` are specified, then only filters for that column
 * associated with the owner are removed.
 */
function removeFilter(filters, _ref2) {
  let {
    column,
    owner
  } = _ref2;
  const filter = filters[column];
  if (!filter) {
    return filters;
  }
  if (owner) {
    for (const type of Object.values(exports.FilterType)) {
      if (owner === filter[type]?.owner) {
        delete filter[type];
      }
    }
  }
  if (!owner || isEmptyObject(filter)) {
    delete filters[column];
  }
  return filters;
}
/**
 * Clears all {@link Filter filters} from the filter set.
 */
function clearFilters(filters) {
  for (const column of Object.keys(filters)) {
    delete filters[column];
  }
  return filters;
}
function hasFilter(filters, _ref3) {
  let {
    column,
    owner
  } = _ref3;
  const filter = filters[column];
  if (!filter) {
    return false;
  }
  if (!owner) {
    return true;
  }
  for (const type of Object.values(exports.FilterType)) {
    if (owner === filter[type]?.owner) {
      return true;
    }
  }
  return false;
}
function getFilter(filters, _ref4) {
  let {
    column,
    type,
    owner
  } = _ref4;
  const filter = filters[column];
  if (!filter) {
    return null;
  }
  if (!owner || owner === filter[type]?.owner) {
    return filter[type] || null;
  }
  return null;
}

/**
 * Returns a {@link SpatialFilter} for a given viewport, typically obtained
 * from deck.gl's `viewport.getBounds()` method ([west, south, east, north]).
 * If the viewport covers the entire world (to some margin of error in Web
 * Mercator space), `undefined` is returned instead.
 *
 * If the viewport extends beyond longitude range [-180, +180], the polygon
 * may be reformatted for compatibility with CARTO APIs.
 */
function createViewportSpatialFilter(viewport) {
  if (_isGlobalViewport(viewport)) {
    return;
  }
  return createPolygonSpatialFilter(bboxPolygon(viewport).geometry);
}
/**
 * Returns a {@link SpatialFilter} for a given {@link Polygon} or
 * {@link MultiPolygon}. If the polygon(s) extend outside longitude
 * range [-180, +180], the result may be reformatted for compatibility
 * with CARTO APIs.
 */
function createPolygonSpatialFilter(spatialFilter) {
  return spatialFilter && _normalizeGeometry(spatialFilter) || undefined;
}
/**
 * Check if a viewport is large enough to represent a global coverage.
 * In this case the spatial filter parameter for widget calculation is removed.
 *
 * @internalRemarks Source: @carto/react-core
 */
function _isGlobalViewport(viewport) {
  const [minx, miny, maxx, maxy] = viewport;
  return maxx - minx > 179.5 * 2 && maxy - miny > 85.05 * 2;
}
/**
 * Normalized a geometry, coming from a mask or a viewport. The parts
 * spanning outside longitude range [-180, +180] are clipped and "folded"
 * back to the valid range and unioned to the polygons inide that range.
 *
 * It results in a Polygon or MultiPolygon strictly inside the validity range.
 *
 * @internalRemarks Source: @carto/react-core
 */
function _normalizeGeometry(geometry) {
  const WORLD = [-180, -90, +180, +90];
  const worldClip = _clean(bboxClip(geometry, WORLD).geometry);
  const geometryTxWest = _tx(geometry, 360);
  const geometryTxEast = _tx(geometry, -360);
  let result = worldClip;
  if (result && geometryTxWest) {
    const worldWestClip = _clean(bboxClip(geometryTxWest, WORLD).geometry);
    if (worldWestClip) {
      const collection = helpers.featureCollection([helpers.feature(result), helpers.feature(worldWestClip)]);
      const merged = union(collection);
      result = merged ? _clean(merged.geometry) : result;
    }
  }
  if (result && geometryTxEast) {
    const worldEastClip = _clean(bboxClip(geometryTxEast, WORLD).geometry);
    if (worldEastClip) {
      const collection = helpers.featureCollection([helpers.feature(result), helpers.feature(worldEastClip)]);
      const merged = union(collection);
      result = merged ? _clean(merged.geometry) : result;
    }
  }
  return result;
}
/** @internalRemarks Source: @carto/react-core */
function _cleanPolygonCoords(cc) {
  const coords = cc.filter(c => c.length > 0);
  return coords.length > 0 ? coords : null;
}
/** @internalRemarks Source: @carto/react-core */
function _cleanMultiPolygonCoords(ccc) {
  const coords = ccc.map(_cleanPolygonCoords).filter(cc => cc);
  return coords.length > 0 ? coords : null;
}
/** @internalRemarks Source: @carto/react-core */
function _clean(geometry) {
  if (!geometry) {
    return null;
  }
  if (_isPolygon(geometry)) {
    const coords = _cleanPolygonCoords(geometry.coordinates);
    return coords ? helpers.polygon(coords).geometry : null;
  }
  if (_isMultiPolygon(geometry)) {
    const coords = _cleanMultiPolygonCoords(geometry.coordinates);
    return coords ? helpers.multiPolygon(coords).geometry : null;
  }
  return null;
}
/** @internalRemarks Source: @carto/react-core */
function _txContourCoords(cc, distance) {
  return cc.map(c => [c[0] + distance, c[1]]);
}
/** @internalRemarks Source: @carto/react-core */
function _txPolygonCoords(ccc, distance) {
  return ccc.map(cc => _txContourCoords(cc, distance));
}
/** @internalRemarks Source: @carto/react-core */
function _txMultiPolygonCoords(cccc, distance) {
  return cccc.map(ccc => _txPolygonCoords(ccc, distance));
}
/** @internalRemarks Source: @carto/react-core */
function _tx(geometry, distance) {
  if (geometry && invariant.getType(geometry) === 'Polygon') {
    const coords = _txPolygonCoords(geometry.coordinates, distance);
    return helpers.polygon(coords).geometry;
  } else if (geometry && invariant.getType(geometry) === 'MultiPolygon') {
    const coords = _txMultiPolygonCoords(geometry.coordinates, distance);
    return helpers.multiPolygon(coords).geometry;
  } else {
    return null;
  }
}
function _isPolygon(geometry) {
  return invariant.getType(geometry) === 'Polygon';
}
function _isMultiPolygon(geometry) {
  return invariant.getType(geometry) === 'MultiPolygon';
}

/**
 * Current version of @carto/api-client.
 * @internal
 */
/** @internal */
const V3_MINOR_VERSION = '3.4';
/** @internalRemarks Source: @carto/constants, @deck.gl/carto */
const DEFAULT_GEO_COLUMN = 'geom';
/**
 * Fastly default limit is 8192; leave some padding.
 * @internalRemarks Source: @deck.gl/carto
 */
const DEFAULT_MAX_LENGTH_URL = 7000;
/** @internalRemarks Source: @deck.gl/carto */
const DEFAULT_TILE_RESOLUTION = 0.5;
/**
 * @internalRemarks Source: @deck.gl/carto
 * @internal
 */
const DEFAULT_AGGREGATION_RES_LEVEL_H3 = 4;
/**
 * @internalRemarks Source: @deck.gl/carto
 * @internal
 */
const DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN = 6;

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
function joinPath() {
  return [].slice.call(arguments).map(part => part.endsWith('/') ? part.slice(0, -1) : part).join('/');
}
function buildV3Path(apiBaseUrl, version, endpoint) {
  return joinPath(apiBaseUrl, version, endpoint, ...[].slice.call(arguments, 3));
}
/** @internal Required by fetchMap(). */
function buildPublicMapUrl(_ref) {
  let {
    apiBaseUrl,
    cartoMapId
  } = _ref;
  return buildV3Path(apiBaseUrl, 'v3', 'maps', 'public', cartoMapId);
}
/** @internal Required by fetchMap(). */
function buildStatsUrl(_ref2) {
  let {
    attribute,
    apiBaseUrl,
    connectionName,
    source,
    type
  } = _ref2;
  if (type === 'query') {
    return buildV3Path(apiBaseUrl, 'v3', 'stats', connectionName, attribute);
  }
  // type === 'table'
  return buildV3Path(apiBaseUrl, 'v3', 'stats', connectionName, source, attribute);
}
function buildSourceUrl(_ref3) {
  let {
    apiBaseUrl,
    connectionName,
    endpoint
  } = _ref3;
  return buildV3Path(apiBaseUrl, 'v3', 'maps', connectionName, endpoint);
}
function buildQueryUrl(_ref4) {
  let {
    apiBaseUrl,
    connectionName
  } = _ref4;
  return buildV3Path(apiBaseUrl, 'v3', 'sql', connectionName, 'query');
}

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/**
 *
 * Custom error for reported errors in CARTO Maps API.
 * Provides useful debugging information in console and context for applications.
 *
 */
class CartoAPIError extends Error {
  constructor(error, errorContext, response, responseJson) {
    let responseString = 'Failed to connect';
    if (response) {
      responseString = 'Server returned: ';
      if (response.status === 400) {
        responseString += 'Bad request';
      } else if (response.status === 401 || response.status === 403) {
        responseString += 'Unauthorized access';
      } else if (response.status === 404) {
        responseString += 'Not found';
      } else {
        responseString += 'Error';
      }
      responseString += ` (${response.status}):`;
    }
    responseString += ` ${error.message || error}`;
    let message = `${errorContext.requestType} API request failed`;
    message += `\n${responseString}`;
    for (const key of Object.keys(errorContext)) {
      if (key === 'requestType') continue;
      message += `\n${formatErrorKey(key)}: ${errorContext[key]}`;
    }
    message += '\n';
    super(message);
    /** Source error from server */
    this.error = void 0;
    /** Context (API call & parameters) in which error occured */
    this.errorContext = void 0;
    /** Response from server */
    this.response = void 0;
    /** JSON Response from server */
    this.responseJson = void 0;
    this.name = 'CartoAPIError';
    this.response = response;
    this.responseJson = responseJson;
    this.error = error;
    this.errorContext = errorContext;
  }
}
/**
 * Converts camelCase to Camel Case
 */
function formatErrorKey(key) {
  return key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
}

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const requestWithParameters = function (_ref) {
  let {
    baseUrl,
    parameters = {},
    headers: customHeaders = {},
    errorContext,
    maxLengthURL = DEFAULT_MAX_LENGTH_URL,
    localCache
  } = _ref;
  try {
    // Parameters added to all requests issued with `requestWithParameters()`.
    // These parameters override parameters already in the base URL, but not
    // user-provided parameters.
    parameters = {
      v: V3_MINOR_VERSION,
      client: getClient(),
      ...(typeof deck !== 'undefined' && deck.VERSION && {
        deckglVersion: deck.VERSION
      }),
      ...parameters
    };
    baseUrl = excludeURLParameters(baseUrl, Object.keys(parameters));
    const key = createCacheKey(baseUrl, parameters, customHeaders);
    const {
      cache: REQUEST_CACHE,
      canReadCache,
      canStoreInCache
    } = getCacheSettings(localCache);
    if (canReadCache && REQUEST_CACHE.has(key)) {
      return Promise.resolve(REQUEST_CACHE.get(key));
    }
    const url = createURLWithParameters(baseUrl, parameters);
    const headers = {
      ...DEFAULT_HEADERS,
      ...customHeaders
    };
    /* global fetch */
    const fetchPromise = url.length > maxLengthURL ? fetch(baseUrl, {
      method: 'POST',
      body: JSON.stringify(parameters),
      headers
    }) : fetch(url, {
      headers
    });
    let response;
    let responseJson;
    const jsonPromise = fetchPromise.then(_response => {
      response = _response;
      return response.json();
    }).then(json => {
      responseJson = json;
      if (!response || !response.ok) {
        throw new Error(json.error);
      }
      return json;
    }).catch(error => {
      if (canStoreInCache) {
        REQUEST_CACHE.delete(key);
      }
      throw new CartoAPIError(error, errorContext, response, responseJson);
    });
    if (canStoreInCache) {
      REQUEST_CACHE.set(key, jsonPromise);
    }
    return Promise.resolve(jsonPromise);
  } catch (e) {
    return Promise.reject(e);
  }
};
const DEFAULT_HEADERS = {
  Accept: 'application/json',
  'Content-Type': 'application/json'
};
const DEFAULT_REQUEST_CACHE = new Map();
function getCacheSettings(localCache) {
  const canReadCache = localCache?.cacheControl?.includes('no-cache') ? false : true;
  const canStoreInCache = localCache?.cacheControl?.includes('no-store') ? false : true;
  const cache = localCache?.cache || DEFAULT_REQUEST_CACHE;
  return {
    cache,
    canReadCache,
    canStoreInCache
  };
}
function createCacheKey(baseUrl, parameters, headers) {
  const parameterEntries = Object.entries(parameters).sort((_ref2, _ref3) => {
    let [a] = _ref2;
    let [b] = _ref3;
    return a > b ? 1 : -1;
  });
  const headerEntries = Object.entries(headers).sort((_ref4, _ref5) => {
    let [a] = _ref4;
    let [b] = _ref5;
    return a > b ? 1 : -1;
  });
  return JSON.stringify({
    baseUrl,
    parameters: parameterEntries,
    headers: headerEntries
  });
}
/**
 * Appends query string parameters to a URL. Existing URL parameters are kept,
 * unless there is a conflict, in which case the new parameters override
 * those already in the URL.
 */
function createURLWithParameters(baseUrlString, parameters) {
  const baseUrl = new URL(baseUrlString);
  for (const [key, value] of Object.entries(parameters)) {
    if (isPureObject(value) || Array.isArray(value)) {
      baseUrl.searchParams.set(key, JSON.stringify(value));
    } else {
      baseUrl.searchParams.set(key, value.toString());
    }
  }
  return baseUrl.toString();
}
/**
 * Deletes query string parameters from a URL.
 */
function excludeURLParameters(baseUrlString, parameters) {
  const baseUrl = new URL(baseUrlString);
  for (const param of parameters) {
    if (baseUrl.searchParams.has(param)) {
      baseUrl.searchParams.delete(param);
    }
  }
  return baseUrl.toString();
}

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const baseSource = function (endpoint, options, urlParameters) {
  try {
    const {
      accessToken,
      connectionName,
      cache,
      ...optionalOptions
    } = options;
    const mergedOptions = {
      ...SOURCE_DEFAULTS,
      accessToken,
      connectionName,
      endpoint
    };
    for (const key in optionalOptions) {
      if (optionalOptions[key]) {
        mergedOptions[key] = optionalOptions[key];
      }
    }
    const baseUrl = buildSourceUrl(mergedOptions);
    const {
      clientId,
      maxLengthURL,
      format,
      localCache
    } = mergedOptions;
    const headers = {
      Authorization: `Bearer ${options.accessToken}`,
      ...options.headers
    };
    const parameters = {
      client: clientId,
      ...urlParameters
    };
    const errorContext = {
      requestType: 'Map instantiation',
      connection: options.connectionName,
      type: endpoint,
      source: JSON.stringify(parameters, undefined, 2)
    };
    return Promise.resolve(requestWithParameters({
      baseUrl,
      parameters,
      headers,
      errorContext,
      maxLengthURL,
      localCache
    })).then(function (mapInstantiation) {
      let _exit;
      function _temp2(_result) {
        return _exit ? _result : Promise.resolve(requestWithParameters({
          baseUrl: dataUrl,
          headers,
          errorContext,
          maxLengthURL,
          localCache
        }));
      }
      const dataUrl = mapInstantiation[format].url[0];
      if (cache) {
        cache.value = parseInt(new URL(dataUrl).searchParams.get('cache') || '', 10);
      }
      errorContext.requestType = 'Map data';
      const _temp = function () {
        if (format === 'tilejson') {
          return Promise.resolve(requestWithParameters({
            baseUrl: dataUrl,
            headers,
            errorContext,
            maxLengthURL,
            localCache
          })).then(function (json) {
            if (accessToken) {
              json.accessToken = accessToken;
            }
            _exit = 1;
            return json;
          });
        }
      }();
      return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);
    });
  } catch (e) {
    return Promise.reject(e);
  }
};
const SOURCE_DEFAULTS = {
  apiBaseUrl: DEFAULT_API_BASE_URL,
  clientId: getClient(),
  format: 'tilejson',
  headers: {},
  maxLengthURL: DEFAULT_MAX_LENGTH_URL
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const boundaryQuerySource = function (options) {
  try {
    const {
      columns,
      filters,
      tilesetTableName,
      propertiesSqlQuery,
      queryParameters
    } = options;
    const urlParameters = {
      tilesetTableName,
      propertiesSqlQuery
    };
    if (columns) {
      urlParameters.columns = columns.join(',');
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    return Promise.resolve(baseSource('boundary', options, urlParameters));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const boundaryTableSource = function (options) {
  try {
    const {
      filters,
      tilesetTableName,
      columns,
      propertiesTableName
    } = options;
    const urlParameters = {
      tilesetTableName,
      propertiesTableName
    };
    if (columns) {
      urlParameters.columns = columns.join(',');
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return Promise.resolve(baseSource('boundary', options, urlParameters));
  } catch (e) {
    return Promise.reject(e);
  }
};

/**
 * Return more descriptive error from API
 * @internalRemarks Source: @carto/react-api
 */

/** @internalRemarks Source: @carto/react-api */

function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
const makeCall = function (_ref2) {
  let {
    url,
    accessToken,
    opts
  } = _ref2;
  try {
    let _exit;
    function _temp2(_result) {
      if (_exit) ;
      if (!response.ok) {
        dealWithApiError({
          response,
          data
        });
      }
      return data;
    }
    let response;
    let data;
    const isPost = opts?.method === 'POST';
    const _temp = _catch(function () {
      return Promise.resolve(fetch(url.toString(), {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          ...(isPost && {
            'Content-Type': 'application/json'
          })
        },
        ...(isPost && {
          method: opts?.method,
          body: opts?.body
        }),
        signal: opts?.abortController?.signal,
        ...opts?.otherOptions
      })).then(function (_fetch) {
        response = _fetch;
        return Promise.resolve(response.json()).then(function (_response$json) {
          data = _response$json;
        });
      });
    }, function (error) {
      if (error.name === 'AbortError') throw error;
      throw new Error(`Failed request: ${error}`);
    });
    return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));
  } catch (e) {
    return Promise.reject(e);
  }
};
function dealWithApiError(_ref) {
  let {
    response,
    data
  } = _ref;
  if (data.error === 'Column not found') {
    throw new InvalidColumnError(`${data.error} ${data.column_name}`);
  }
  if (typeof data.error === 'string' && data.error?.includes('Missing columns')) {
    throw new InvalidColumnError(data.error);
  }
  switch (response.status) {
    case 401:
      throw new Error('Unauthorized access. Invalid credentials');
    case 403:
      throw new Error('Forbidden access to the requested data');
    default:
      const msg = data && data.error && typeof data.error === 'string' ? data.error : JSON.stringify(data?.hint || data.error?.[0]);
      throw new Error(msg);
  }
}

/** @internalRemarks Source: @carto/react-api */
const AVAILABLE_MODELS = ['category', 'histogram', 'formula', 'pick', 'timeseries', 'range', 'scatterplot', 'table'];
const {
  V3
} = exports.ApiVersion;
const REQUEST_GET_MAX_URL_LENGTH = 2048;
/**
 * Execute a SQL model request.
 * @internalRemarks Source: @carto/react-api
 */
function executeModel(props) {
  assert(props.source, 'executeModel: missing source');
  assert(props.model, 'executeModel: missing model');
  assert(props.params, 'executeModel: missing params');
  assert(AVAILABLE_MODELS.includes(props.model), `executeModel: model provided isn't valid. Available models: ${AVAILABLE_MODELS.join(', ')}`);
  const {
    model,
    source,
    params,
    opts
  } = props;
  const {
    type,
    apiVersion,
    apiBaseUrl,
    accessToken,
    connectionName,
    clientId
  } = source;
  assert(apiBaseUrl, 'executeModel: missing apiBaseUrl');
  assert(accessToken, 'executeModel: missing accessToken');
  assert(apiVersion === V3, 'executeModel: SQL Model API requires CARTO 3+');
  assert(type !== 'tileset', 'executeModel: Tilesets not supported');
  let url = `${apiBaseUrl}/v3/sql/${connectionName}/model/${model}`;
  const {
    data,
    filters,
    filtersLogicalOperator = 'and',
    spatialDataType = 'geo',
    spatialFiltersMode = 'intersects',
    spatialFiltersResolution = 0
  } = source;
  const queryParams = {
    type,
    client: clientId,
    source: data,
    params,
    queryParameters: source.queryParameters || '',
    filters,
    filtersLogicalOperator
  };
  const spatialDataColumn = source.spatialDataColumn || DEFAULT_GEO_COLUMN;
  // Picking Model API requires 'spatialDataColumn'.
  if (model === 'pick') {
    queryParams.spatialDataColumn = spatialDataColumn;
  }
  // API supports multiple filters, we apply it only to spatialDataColumn
  const spatialFilters = source.spatialFilter ? {
    [spatialDataColumn]: source.spatialFilter
  } : undefined;
  if (spatialFilters) {
    queryParams.spatialFilters = spatialFilters;
    queryParams.spatialDataColumn = spatialDataColumn;
    queryParams.spatialDataType = spatialDataType;
  }
  if (spatialDataType !== 'geo') {
    if (spatialFiltersResolution > 0) {
      queryParams.spatialFiltersResolution = spatialFiltersResolution;
    }
    queryParams.spatialFiltersMode = spatialFiltersMode;
  }
  const urlWithSearchParams = url + '?' + objectToURLSearchParams(queryParams).toString();
  const isGet = urlWithSearchParams.length <= REQUEST_GET_MAX_URL_LENGTH;
  if (isGet) {
    url = urlWithSearchParams;
  }
  return makeCall({
    url,
    accessToken: source.accessToken,
    opts: {
      ...opts,
      method: isGet ? 'GET' : 'POST',
      ...(!isGet && {
        body: JSON.stringify(queryParams)
      })
    }
  });
}
function objectToURLSearchParams(object) {
  const params = new URLSearchParams();
  for (const key in object) {
    if (isPureObject(object[key])) {
      params.append(key, JSON.stringify(object[key]));
    } else if (Array.isArray(object[key])) {
      params.append(key, JSON.stringify(object[key]));
    } else if (object[key] === null) {
      params.append(key, 'null');
    } else if (object[key] !== undefined) {
      params.append(key, String(object[key]));
    }
  }
  return params;
}

const DEFAULT_TILE_SIZE = 512;
const QUADBIN_ZOOM_MAX_OFFSET = 4;
function getSpatialFiltersResolution(source, viewState) {
  const dataResolution = source.dataResolution ?? Number.MAX_VALUE;
  const aggregationResLevel = source.aggregationResLevel ?? (source.spatialDataType === 'h3' ? DEFAULT_AGGREGATION_RES_LEVEL_H3 : DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN);
  const aggregationResLevelOffset = Math.max(0, Math.floor(aggregationResLevel));
  const currentZoomInt = Math.ceil(viewState.zoom);
  if (source.spatialDataType === 'h3') {
    const tileSize = DEFAULT_TILE_SIZE;
    const maxResolutionForZoom = maxH3SpatialFiltersResolutions.find(_ref => {
      let [zoom] = _ref;
      return zoom === currentZoomInt;
    })?.[1] ?? Math.max(0, currentZoomInt - 3);
    const maxSpatialFiltersResolution = maxResolutionForZoom ? Math.min(dataResolution, maxResolutionForZoom) : dataResolution;
    const hexagonResolution = getHexagonResolution(viewState, tileSize) + aggregationResLevelOffset;
    return Math.min(hexagonResolution, maxSpatialFiltersResolution);
  }
  if (source.spatialDataType === 'quadbin') {
    const maxResolutionForZoom = currentZoomInt + QUADBIN_ZOOM_MAX_OFFSET;
    const maxSpatialFiltersResolution = Math.min(dataResolution, maxResolutionForZoom);
    const quadsResolution = Math.floor(viewState.zoom) + aggregationResLevelOffset;
    return Math.min(quadsResolution, maxSpatialFiltersResolution);
  }
  return undefined;
}
const maxH3SpatialFiltersResolutions = [[20, 14], [19, 13], [18, 12], [17, 11], [16, 10], [15, 9], [14, 8], [13, 7], [12, 7], [11, 7], [10, 6], [9, 6], [8, 5], [7, 4], [6, 4], [5, 3], [4, 2], [3, 1], [2, 1], [1, 0]];
// stolen from https://github.com/visgl/deck.gl/blob/master/modules/carto/src/layers/h3-tileset-2d.ts
// Relative scale factor (0 = no biasing, 2 = a few hexagons cover view)
const BIAS = 2;
// Resolution conversion function. Takes a WebMercatorViewport and returns
// a H3 resolution such that the screen space size of the hexagons is
// similar
function getHexagonResolution(viewport, tileSize) {
  // Difference in given tile size compared to deck's internal 512px tile size,
  // expressed as an offset to the viewport zoom.
  const zoomOffset = Math.log2(tileSize / DEFAULT_TILE_SIZE);
  const hexagonScaleFactor = 2 / 3 * (viewport.zoom - zoomOffset);
  const latitudeScaleFactor = Math.log(1 / Math.cos(Math.PI * viewport.latitude / 180));
  // Clip and bias
  return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));
}

/**
 * Source for Widget API requests on a data source defined by a SQL query.
 *
 * Abstract class. Use {@link WidgetQuerySource} or {@link WidgetTableSource}.
 */
class WidgetBaseSource {
  constructor(props) {
    this.props = void 0;
    this.props = {
      ...WidgetBaseSource.defaultProps,
      ...props
    };
  }
  _getModelSource(owner) {
    const props = this.props;
    return {
      apiVersion: props.apiVersion,
      apiBaseUrl: props.apiBaseUrl,
      clientId: props.clientId,
      accessToken: props.accessToken,
      connectionName: props.connectionName,
      filters: getApplicableFilters(owner, props.filters),
      filtersLogicalOperator: props.filtersLogicalOperator,
      spatialDataType: props.spatialDataType,
      spatialDataColumn: props.spatialDataColumn,
      dataResolution: props.dataResolution
    };
  }
  _getSpatialFiltersResolution(source, spatialFilter, referenceViewState) {
    // spatialFiltersResolution applies only to spatial index sources.
    if (!spatialFilter || source.spatialDataType === 'geo') {
      return;
    }
    if (!referenceViewState) {
      throw new Error('Missing required option, "spatialIndexReferenceViewState".');
    }
    return getSpatialFiltersResolution(source, referenceViewState);
  }
  /****************************************************************************
   * CATEGORIES
   */
  /**
   * Returns a list of labeled datapoints for categorical data. Suitable for
   * charts including grouped bar charts, pie charts, and tree charts.
   */
  getCategories(options) {
    try {
      const _this = this;
      const {
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        abortController,
        ...params
      } = options;
      const {
        column,
        operation,
        operationColumn
      } = params;
      const source = _this.getModelSource(filterOwner);
      const spatialFiltersResolution = _this._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      return Promise.resolve(executeModel({
        model: 'category',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column,
          operation,
          operationColumn: operationColumn || column
        },
        opts: {
          abortController
        }
      }).then(res => normalizeObjectKeys(res.rows)));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /****************************************************************************
   * FEATURES
   */
  /**
   * Given a list of feature IDs (as found in `_carto_feature_id`) returns all
   * matching features. In datasets containing features with duplicate geometries,
   * feature IDs may be duplicated (IDs are a hash of geometry) and so more
   * results may be returned than IDs in the request.
   * @internal
   * @experimental
   */
  getFeatures(options) {
    try {
      const _this2 = this;
      const {
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        abortController,
        ...params
      } = options;
      const {
        columns,
        dataType,
        featureIds,
        z,
        limit,
        tileResolution
      } = params;
      const source = _this2.getModelSource(filterOwner);
      const spatialFiltersResolution = _this2._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      return Promise.resolve(executeModel({
        model: 'pick',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          columns,
          dataType,
          featureIds,
          z,
          limit: limit || 1000,
          tileResolution: tileResolution || DEFAULT_TILE_RESOLUTION
        },
        opts: {
          abortController
        }
        // Avoid `normalizeObjectKeys()`, which changes column names.
      }).then(_ref => {
        let {
          rows
        } = _ref;
        return {
          rows
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /****************************************************************************
   * FORMULA
   */
  /**
   * Returns a scalar numerical statistic over all matching data. Suitable
   * for 'headline' or 'scorecard' figures such as counts and sums.
   */
  getFormula(options) {
    try {
      const _this3 = this;
      const {
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        abortController,
        operationExp,
        ...params
      } = options;
      const {
        column,
        operation
      } = params;
      const source = _this3.getModelSource(filterOwner);
      const spatialFiltersResolution = _this3._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      return Promise.resolve(executeModel({
        model: 'formula',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column: column ?? '*',
          operation,
          operationExp
        },
        opts: {
          abortController
        }
      }).then(res => normalizeObjectKeys(res.rows[0])));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /****************************************************************************
   * HISTOGRAM
   */
  /**
   * Returns a list of labeled datapoints for 'bins' of data defined as ticks
   * over a numerical range. Suitable for histogram charts.
   */
  getHistogram(options) {
    try {
      const _this4 = this;
      const {
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        abortController,
        ...params
      } = options;
      const {
        column,
        operation,
        ticks
      } = params;
      const source = _this4.getModelSource(filterOwner);
      const spatialFiltersResolution = _this4._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      return Promise.resolve(executeModel({
        model: 'histogram',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column,
          operation,
          ticks
        },
        opts: {
          abortController
        }
      }).then(res => normalizeObjectKeys(res.rows))).then(function (data) {
        if (data.length) {
          // Given N ticks the API returns up to N+1 bins, omitting any empty bins. Bins
          // include 1 bin below the lowest tick, N-1 between ticks, and 1 bin above the highest tick.
          const result = Array(ticks.length + 1).fill(0);
          data.forEach(_ref2 => {
            let {
              tick,
              value
            } = _ref2;
            return result[tick] = value;
          });
          return result;
        }
        return [];
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /****************************************************************************
   * RANGE
   */
  /**
   * Returns a range (min and max) for a numerical column of matching rows.
   * Suitable for displaying certain 'headline' or 'scorecard' statistics,
   * or rendering a range slider UI for filtering.
   */
  getRange(options) {
    try {
      const _this5 = this;
      const {
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        abortController,
        ...params
      } = options;
      const {
        column
      } = params;
      const source = _this5.getModelSource(filterOwner);
      const spatialFiltersResolution = _this5._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      return Promise.resolve(executeModel({
        model: 'range',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column
        },
        opts: {
          abortController
        }
      }).then(res => normalizeObjectKeys(res.rows[0])));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /****************************************************************************
   * SCATTER
   */
  /**
   * Returns a list of bivariate datapoints defined as numerical 'x' and 'y'
   * values. Suitable for rendering scatter plots.
   */
  getScatter(options) {
    try {
      const _this6 = this;
      const {
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        abortController,
        ...params
      } = options;
      const {
        xAxisColumn,
        xAxisJoinOperation,
        yAxisColumn,
        yAxisJoinOperation
      } = params;
      const source = _this6.getModelSource(filterOwner);
      const spatialFiltersResolution = _this6._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      // Make sure this is sync with the same constant in cloud-native/maps-api
      const HARD_LIMIT = 500;
      return Promise.resolve(executeModel({
        model: 'scatterplot',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          xAxisColumn,
          xAxisJoinOperation,
          yAxisColumn,
          yAxisJoinOperation,
          limit: HARD_LIMIT
        },
        opts: {
          abortController
        }
      }).then(res => normalizeObjectKeys(res.rows)).then(res => res.map(_ref3 => {
        let {
          x,
          y
        } = _ref3;
        return [x, y];
      })));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /****************************************************************************
   * TABLE
   */
  /**
   * Returns a list of arbitrary data rows, with support for pagination and
   * sorting. Suitable for displaying tables and lists.
   */
  getTable(options) {
    try {
      const _this7 = this;
      const {
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        abortController,
        ...params
      } = options;
      const {
        columns,
        sortBy,
        sortDirection,
        offset = 0,
        limit = 10
      } = params;
      const source = _this7.getModelSource(filterOwner);
      const spatialFiltersResolution = _this7._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      return Promise.resolve(executeModel({
        model: 'table',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column: columns,
          sortBy,
          sortDirection,
          limit,
          offset
        },
        opts: {
          abortController
        }
      }).then(res => ({
        // Avoid `normalizeObjectKeys()`, which changes column names.
        rows: res.rows ?? res.ROWS,
        totalCount: res.metadata?.total ?? res.METADATA?.TOTAL
      })));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /****************************************************************************
   * TIME SERIES
   */
  /**
   * Returns a series of labeled numerical values, grouped into equally-sized
   * time intervals. Suitable for rendering time series charts.
   */
  getTimeSeries(options) {
    try {
      const _this8 = this;
      const {
        filterOwner,
        abortController,
        spatialFilter,
        spatialFiltersMode,
        spatialIndexReferenceViewState,
        ...params
      } = options;
      const {
        column,
        operationColumn,
        joinOperation,
        operation,
        stepSize,
        stepMultiplier,
        splitByCategory,
        splitByCategoryLimit,
        splitByCategoryValues
      } = params;
      const source = _this8.getModelSource(filterOwner);
      const spatialFiltersResolution = _this8._getSpatialFiltersResolution(source, spatialFilter, spatialIndexReferenceViewState);
      return Promise.resolve(executeModel({
        model: 'timeseries',
        source: {
          ...source,
          spatialFiltersResolution,
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column,
          stepSize,
          stepMultiplier,
          operationColumn: operationColumn || column,
          joinOperation,
          operation,
          splitByCategory,
          splitByCategoryLimit,
          splitByCategoryValues
        },
        opts: {
          abortController
        }
      }).then(res => ({
        rows: normalizeObjectKeys(res.rows),
        categories: res.metadata?.categories
      })));
    } catch (e) {
      return Promise.reject(e);
    }
  }
}
WidgetBaseSource.defaultProps = {
  apiVersion: exports.ApiVersion.V3,
  apiBaseUrl: DEFAULT_API_BASE_URL,
  clientId: getClient(),
  filters: {},
  filtersLogicalOperator: 'and'
};

/**
 * Source for Widget API requests on a data source defined by a SQL query.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorQuerySource}, {@link h3QuerySource}, or {@link quadbinQuerySource},
 * which can be shared with map layers. Sources contain a `widgetSource` property,
 * for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorQuerySource } from '@carto/api-client';
 *
 * const data = vectorQuerySource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   sqlQuery: 'SELECT * FROM carto-demo-data.demo_tables.retail_stores'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
class WidgetQuerySource extends WidgetBaseSource {
  getModelSource(owner) {
    return {
      ...super._getModelSource(owner),
      type: 'query',
      data: this.props.sqlQuery,
      queryParameters: this.props.queryParameters
    };
  }
}

/**
 * Source for Widget API requests on a data source defined as a table.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorTableSource}, {@link h3TableSource}, or {@link quadbinTableSource},
 * which can be shared with map layers. Sources contain a `widgetSource` property,
 * for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorTableSource } from '@carto/api-client';
 *
 * const data = vectorTableSource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   tableName: 'carto-demo-data.demo_tables.retail_stores'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
class WidgetTableSource extends WidgetBaseSource {
  getModelSource(owner) {
    return {
      ...super._getModelSource(owner),
      type: 'table',
      data: this.props.tableName
    };
  }
}

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable camelcase */
const h3QuerySource = function (options) {
  try {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3,
      sqlQuery,
      spatialDataColumn = 'h3',
      queryParameters,
      filters
    } = options;
    const spatialDataType = 'h3';
    const urlParameters = {
      aggregationExp,
      spatialDataColumn,
      spatialDataType,
      q: sqlQuery
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return Promise.resolve(baseSource('query', options, urlParameters).then(result => ({
      ...result,
      widgetSource: new WidgetQuerySource({
        ...options,
        // NOTE: Parameters with default values above must be explicitly passed here.
        spatialDataColumn,
        spatialDataType
      })
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable camelcase */
const h3TableSource = function (options) {
  try {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3,
      spatialDataColumn = 'h3',
      tableName,
      filters
    } = options;
    const spatialDataType = 'h3';
    const urlParameters = {
      aggregationExp,
      name: tableName,
      spatialDataColumn,
      spatialDataType
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return Promise.resolve(baseSource('table', options, urlParameters).then(result => ({
      ...result,
      widgetSource: new WidgetTableSource({
        ...options,
        // NOTE: Parameters with default values above must be explicitly passed here.
        spatialDataColumn,
        spatialDataType
      })
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const h3TilesetSource = function (options) {
  try {
    const {
      tableName
    } = options;
    const urlParameters = {
      name: tableName
    };
    return Promise.resolve(baseSource('tileset', options, urlParameters));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const rasterSource = function (options) {
  try {
    const {
      tableName,
      filters
    } = options;
    const urlParameters = {
      name: tableName
    };
    if (filters) {
      urlParameters.filters = filters;
    }
    return Promise.resolve(baseSource('raster', options, urlParameters));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable camelcase */
const quadbinQuerySource = function (options) {
  try {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN,
      sqlQuery,
      spatialDataColumn = 'quadbin',
      queryParameters,
      filters
    } = options;
    const spatialDataType = 'quadbin';
    const urlParameters = {
      aggregationExp,
      q: sqlQuery,
      spatialDataColumn,
      spatialDataType
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return Promise.resolve(baseSource('query', options, urlParameters).then(result => ({
      ...result,
      widgetSource: new WidgetQuerySource({
        ...options,
        // NOTE: Parameters with default values above must be explicitly passed here.
        spatialDataColumn,
        spatialDataType
      })
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable camelcase */
const quadbinTableSource = function (options) {
  try {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN,
      spatialDataColumn = 'quadbin',
      tableName,
      filters
    } = options;
    const spatialDataType = 'quadbin';
    const urlParameters = {
      aggregationExp,
      name: tableName,
      spatialDataColumn,
      spatialDataType
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return Promise.resolve(baseSource('table', options, urlParameters).then(result => ({
      ...result,
      widgetSource: new WidgetTableSource({
        ...options,
        // NOTE: Parameters with default values above must be explicitly passed here.
        spatialDataColumn,
        spatialDataType
      })
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const quadbinTilesetSource = function (options) {
  try {
    const {
      tableName
    } = options;
    const urlParameters = {
      name: tableName
    };
    return Promise.resolve(baseSource('tileset', options, urlParameters));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable camelcase */
const vectorQuerySource = function (options) {
  try {
    const {
      columns,
      filters,
      spatialDataColumn = 'geom',
      sqlQuery,
      tileResolution = DEFAULT_TILE_RESOLUTION,
      queryParameters,
      aggregationExp
    } = options;
    const spatialDataType = 'geo';
    const urlParameters = {
      spatialDataColumn,
      spatialDataType,
      tileResolution: tileResolution.toString(),
      q: sqlQuery
    };
    if (columns) {
      urlParameters.columns = columns.join(',');
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    if (aggregationExp) {
      urlParameters.aggregationExp = aggregationExp;
    }
    return Promise.resolve(baseSource('query', options, urlParameters).then(result => ({
      ...result,
      widgetSource: new WidgetQuerySource({
        ...options,
        // NOTE: Parameters with default values above must be explicitly passed here.
        spatialDataColumn,
        spatialDataType,
        tileResolution
      })
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
/* eslint-disable camelcase */
const vectorTableSource = function (options) {
  try {
    const {
      columns,
      filters,
      spatialDataColumn = 'geom',
      tableName,
      tileResolution = DEFAULT_TILE_RESOLUTION,
      aggregationExp
    } = options;
    const spatialDataType = 'geo';
    const urlParameters = {
      name: tableName,
      spatialDataColumn,
      spatialDataType,
      tileResolution: tileResolution.toString()
    };
    if (columns) {
      urlParameters.columns = columns.join(',');
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    if (aggregationExp) {
      urlParameters.aggregationExp = aggregationExp;
    }
    return Promise.resolve(baseSource('table', options, urlParameters).then(result => ({
      ...result,
      widgetSource: new WidgetTableSource({
        ...options,
        // NOTE: Parameters with default values above must be explicitly passed here.
        spatialDataColumn,
        spatialDataType,
        tileResolution
      })
    })));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const vectorTilesetSource = function (options) {
  try {
    const {
      tableName
    } = options;
    const urlParameters = {
      name: tableName
    };
    return Promise.resolve(baseSource('tileset', options, urlParameters));
  } catch (e) {
    return Promise.reject(e);
  }
};

// deck.gl
// SPDX-License-Identifier: MIT
// Copyright (c) vis.gl contributors
const query = function (options) {
  try {
    const {
      apiBaseUrl = SOURCE_DEFAULTS.apiBaseUrl,
      clientId = SOURCE_DEFAULTS.clientId,
      maxLengthURL = SOURCE_DEFAULTS.maxLengthURL,
      localCache,
      connectionName,
      sqlQuery,
      queryParameters
    } = options;
    const urlParameters = {
      q: sqlQuery
    };
    if (queryParameters) {
      urlParameters.queryParameters = JSON.stringify(queryParameters);
    }
    const baseUrl = buildQueryUrl({
      apiBaseUrl,
      connectionName
    });
    const headers = {
      Authorization: `Bearer ${options.accessToken}`,
      ...options.headers
    };
    const parameters = {
      client: clientId,
      ...urlParameters
    };
    const errorContext = {
      requestType: 'SQL',
      connection: options.connectionName,
      type: 'query',
      source: JSON.stringify(parameters, undefined, 2)
    };
    return Promise.resolve(requestWithParameters({
      baseUrl,
      parameters,
      headers,
      errorContext,
      maxLengthURL,
      localCache
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

exports.CartoAPIError = CartoAPIError;
exports.DEFAULT_API_BASE_URL = DEFAULT_API_BASE_URL;
exports.SOURCE_DEFAULTS = SOURCE_DEFAULTS;
exports.WidgetBaseSource = WidgetBaseSource;
exports.WidgetQuerySource = WidgetQuerySource;
exports.WidgetTableSource = WidgetTableSource;
exports.addFilter = addFilter;
exports.boundaryQuerySource = boundaryQuerySource;
exports.boundaryTableSource = boundaryTableSource;
exports.buildPublicMapUrl = buildPublicMapUrl;
exports.buildStatsUrl = buildStatsUrl;
exports.clearFilters = clearFilters;
exports.createPolygonSpatialFilter = createPolygonSpatialFilter;
exports.createViewportSpatialFilter = createViewportSpatialFilter;
exports.getClient = getClient;
exports.getFilter = getFilter;
exports.h3QuerySource = h3QuerySource;
exports.h3TableSource = h3TableSource;
exports.h3TilesetSource = h3TilesetSource;
exports.hasFilter = hasFilter;
exports.quadbinQuerySource = quadbinQuerySource;
exports.quadbinTableSource = quadbinTableSource;
exports.quadbinTilesetSource = quadbinTilesetSource;
exports.query = query;
exports.rasterSource = rasterSource;
exports.removeFilter = removeFilter;
exports.requestWithParameters = requestWithParameters;
exports.setClient = setClient;
exports.vectorQuerySource = vectorQuerySource;
exports.vectorTableSource = vectorTableSource;
exports.vectorTilesetSource = vectorTilesetSource;
//# sourceMappingURL=api-client.cjs.map
